   1              		.file	"syscalls.c"
   2              		.text
   3              	.Ltext0:
   4              		.cfi_sections	.debug_frame
   5              		.align	2
   6              		.global	_read_r
   8              	_read_r:
   9              	.LFB0:
  10              		.file 1 "../Library/system/syscalls.c"
   1:../Library/system/syscalls.c **** /***********************************************************************/
   2:../Library/system/syscalls.c **** /*                                                                     */
   3:../Library/system/syscalls.c **** /*  SYSCALLS.C:  System Calls Remapping                                */
   4:../Library/system/syscalls.c **** /*  most of this is from newlib-lpc and a Keil-demo                    */
   5:../Library/system/syscalls.c **** /*                                                                     */
   6:../Library/system/syscalls.c **** /*  these are "reentrant functions" as needed by                       */
   7:../Library/system/syscalls.c **** /*  the WinARM-newlib-config, see newlib-manual                        */
   8:../Library/system/syscalls.c **** /*  collected and modified by Martin Thomas                            */
   9:../Library/system/syscalls.c **** /*  TODO: some more work has to be done on this                        */
  10:../Library/system/syscalls.c **** /***********************************************************************/
  11:../Library/system/syscalls.c **** 
  12:../Library/system/syscalls.c **** #include <stdlib.h>
  13:../Library/system/syscalls.c **** #include <reent.h>
  14:../Library/system/syscalls.c **** #include <sys/stat.h>
  15:../Library/system/syscalls.c **** //#include "uart.h"
  16:../Library/system/syscalls.c **** 
  17:../Library/system/syscalls.c **** _ssize_t _read_r(
  18:../Library/system/syscalls.c ****     struct _reent *r, 
  19:../Library/system/syscalls.c ****     int file, 
  20:../Library/system/syscalls.c ****     void *ptr, 
  21:../Library/system/syscalls.c ****     size_t len)
  22:../Library/system/syscalls.c **** {
  11              		.loc 1 22 0
  12              		.cfi_startproc
  13              		@ Function supports interworking.
  14              		@ args = 0, pretend = 0, frame = 0
  15              		@ frame_needed = 0, uses_anonymous_args = 0
  16              		@ link register save eliminated.
  17              	.LVL0:
  23:../Library/system/syscalls.c **** /*	
  24:../Library/system/syscalls.c **** 	char c;
  25:../Library/system/syscalls.c **** 	int  i;
  26:../Library/system/syscalls.c **** 	unsigned char *p;
  27:../Library/system/syscalls.c **** 	
  28:../Library/system/syscalls.c **** 	p = (unsigned char*)ptr;
  29:../Library/system/syscalls.c **** 	
  30:../Library/system/syscalls.c **** 	for (i = 0; i < len; i++) {
  31:../Library/system/syscalls.c **** 		// c = uart0Getch();
  32:../Library/system/syscalls.c **** 		c = uart0GetchW();
  33:../Library/system/syscalls.c **** 		if (c == 0x0D) {
  34:../Library/system/syscalls.c **** 			*p='\0';
  35:../Library/system/syscalls.c **** 			break;
  36:../Library/system/syscalls.c **** 		}
  37:../Library/system/syscalls.c **** 		*p++ = c;
  38:../Library/system/syscalls.c **** 		uart0Putch(c);
  39:../Library/system/syscalls.c **** 	}
  40:../Library/system/syscalls.c **** */
  41:../Library/system/syscalls.c **** //	return len - i;
  42:../Library/system/syscalls.c **** 	return 0;
  43:../Library/system/syscalls.c **** }
  18              		.loc 1 43 0
  19 0000 0000A0E3 		mov	r0, #0
  20              	.LVL1:
  21 0004 1EFF2FE1 		bx	lr
  22              		.cfi_endproc
  23              	.LFE0:
  25              		.align	2
  26              		.global	_write_r
  28              	_write_r:
  29              	.LFB1:
  44:../Library/system/syscalls.c **** 
  45:../Library/system/syscalls.c **** _ssize_t _write_r (
  46:../Library/system/syscalls.c ****     struct _reent *r, 
  47:../Library/system/syscalls.c ****     int file, 
  48:../Library/system/syscalls.c ****     const void *ptr, 
  49:../Library/system/syscalls.c ****     size_t len)
  50:../Library/system/syscalls.c **** {
  30              		.loc 1 50 0
  31              		.cfi_startproc
  32              		@ Function supports interworking.
  33              		@ args = 0, pretend = 0, frame = 0
  34              		@ frame_needed = 0, uses_anonymous_args = 0
  35              		@ link register save eliminated.
  36              	.LVL2:
  51:../Library/system/syscalls.c **** /*
  52:../Library/system/syscalls.c **** 	int i;
  53:../Library/system/syscalls.c **** 	const unsigned char *p;
  54:../Library/system/syscalls.c **** 	
  55:../Library/system/syscalls.c **** 	p = (const unsigned char*) ptr;
  56:../Library/system/syscalls.c **** 	
  57:../Library/system/syscalls.c **** 	for (i = 0; i < len; i++) {
  58:../Library/system/syscalls.c **** 		if (*p == '\n' ) uart0Putch('\r');
  59:../Library/system/syscalls.c **** 		uart0Putch(*p++);
  60:../Library/system/syscalls.c **** 	}
  61:../Library/system/syscalls.c **** */
  62:../Library/system/syscalls.c **** 	return len;
  63:../Library/system/syscalls.c **** }
  37              		.loc 1 63 0
  38 0008 0300A0E1 		mov	r0, r3
  39              	.LVL3:
  40 000c 1EFF2FE1 		bx	lr
  41              		.cfi_endproc
  42              	.LFE1:
  44              		.align	2
  45              		.global	_close_r
  47              	_close_r:
  48              	.LFB2:
  64:../Library/system/syscalls.c **** 
  65:../Library/system/syscalls.c **** int _close_r(
  66:../Library/system/syscalls.c ****     struct _reent *r, 
  67:../Library/system/syscalls.c ****     int file)
  68:../Library/system/syscalls.c **** {
  49              		.loc 1 68 0
  50              		.cfi_startproc
  51              		@ Function supports interworking.
  52              		@ args = 0, pretend = 0, frame = 0
  53              		@ frame_needed = 0, uses_anonymous_args = 0
  54              		@ link register save eliminated.
  55              	.LVL4:
  69:../Library/system/syscalls.c **** 	return 0;
  70:../Library/system/syscalls.c **** }
  56              		.loc 1 70 0
  57 0010 0000A0E3 		mov	r0, #0
  58              	.LVL5:
  59 0014 1EFF2FE1 		bx	lr
  60              		.cfi_endproc
  61              	.LFE2:
  63              		.align	2
  64              		.global	_lseek_r
  66              	_lseek_r:
  67              	.LFB3:
  71:../Library/system/syscalls.c **** 
  72:../Library/system/syscalls.c **** _off_t _lseek_r(
  73:../Library/system/syscalls.c ****     struct _reent *r, 
  74:../Library/system/syscalls.c ****     int file, 
  75:../Library/system/syscalls.c ****     _off_t ptr, 
  76:../Library/system/syscalls.c ****     int dir)
  77:../Library/system/syscalls.c **** {
  68              		.loc 1 77 0
  69              		.cfi_startproc
  70              		@ Function supports interworking.
  71              		@ args = 0, pretend = 0, frame = 0
  72              		@ frame_needed = 0, uses_anonymous_args = 0
  73              		@ link register save eliminated.
  74              	.LVL6:
  78:../Library/system/syscalls.c **** 	return (_off_t)0;	/*  Always indicate we are at file beginning.	*/
  79:../Library/system/syscalls.c **** }
  75              		.loc 1 79 0
  76 0018 0000A0E3 		mov	r0, #0
  77              	.LVL7:
  78 001c 1EFF2FE1 		bx	lr
  79              		.cfi_endproc
  80              	.LFE3:
  82              		.align	2
  83              		.global	_fstat_r
  85              	_fstat_r:
  86              	.LFB4:
  80:../Library/system/syscalls.c **** 
  81:../Library/system/syscalls.c **** 
  82:../Library/system/syscalls.c **** int _fstat_r(
  83:../Library/system/syscalls.c ****     struct _reent *r, 
  84:../Library/system/syscalls.c ****     int file, 
  85:../Library/system/syscalls.c ****     struct stat *st)
  86:../Library/system/syscalls.c **** {
  87              		.loc 1 86 0
  88              		.cfi_startproc
  89              		@ Function supports interworking.
  90              		@ args = 0, pretend = 0, frame = 0
  91              		@ frame_needed = 0, uses_anonymous_args = 0
  92              		@ link register save eliminated.
  93              	.LVL8:
  87:../Library/system/syscalls.c **** 	/*  Always set as character device.				*/
  88:../Library/system/syscalls.c **** 	st->st_mode = S_IFCHR;	
  94              		.loc 1 88 0
  95 0020 023AA0E3 		mov	r3, #8192
  96 0024 043082E5 		str	r3, [r2, #4]
  89:../Library/system/syscalls.c **** 		/* assigned to strong type with implicit 	*/
  90:../Library/system/syscalls.c **** 		/* signed/unsigned conversion.  Required by 	*/
  91:../Library/system/syscalls.c **** 		/* newlib.					*/
  92:../Library/system/syscalls.c **** 
  93:../Library/system/syscalls.c **** 	return 0;
  94:../Library/system/syscalls.c **** }
  97              		.loc 1 94 0
  98 0028 0000A0E3 		mov	r0, #0
  99              	.LVL9:
 100 002c 1EFF2FE1 		bx	lr
 101              		.cfi_endproc
 102              	.LFE4:
 104              		.align	2
 105              		.global	isatty
 107              	isatty:
 108              	.LFB5:
  95:../Library/system/syscalls.c **** 
  96:../Library/system/syscalls.c **** int isatty(int file); /* avoid warning */
  97:../Library/system/syscalls.c **** 
  98:../Library/system/syscalls.c **** int isatty(int file)
  99:../Library/system/syscalls.c **** {
 109              		.loc 1 99 0
 110              		.cfi_startproc
 111              		@ Function supports interworking.
 112              		@ args = 0, pretend = 0, frame = 0
 113              		@ frame_needed = 0, uses_anonymous_args = 0
 114              		@ link register save eliminated.
 115              	.LVL10:
 100:../Library/system/syscalls.c **** 	return 1;
 101:../Library/system/syscalls.c **** }
 116              		.loc 1 101 0
 117 0030 0100A0E3 		mov	r0, #1
 118              	.LVL11:
 119 0034 1EFF2FE1 		bx	lr
 120              		.cfi_endproc
 121              	.LFE5:
 123              		.align	2
 124              		.global	_sbrk_r
 126              	_sbrk_r:
 127              	.LFB6:
 102:../Library/system/syscalls.c **** 
 103:../Library/system/syscalls.c **** #if 0
 104:../Library/system/syscalls.c **** static void _exit (int n) {
 105:../Library/system/syscalls.c **** label:  goto label; /* endless loop */
 106:../Library/system/syscalls.c **** }
 107:../Library/system/syscalls.c **** #endif 
 108:../Library/system/syscalls.c **** 
 109:../Library/system/syscalls.c **** /* "malloc clue function" */
 110:../Library/system/syscalls.c **** 
 111:../Library/system/syscalls.c **** 	/**** Locally used variables. ****/
 112:../Library/system/syscalls.c **** extern char end[];              /*  end is set in the linker command 	*/
 113:../Library/system/syscalls.c **** 				/* file and is the end of statically 	*/
 114:../Library/system/syscalls.c **** 				/* allocated data (thus start of heap).	*/
 115:../Library/system/syscalls.c **** 
 116:../Library/system/syscalls.c **** static char *heap_ptr;		/* Points to current end of the heap.	*/
 117:../Library/system/syscalls.c **** 
 118:../Library/system/syscalls.c **** /************************** _sbrk_r *************************************/
 119:../Library/system/syscalls.c **** /*  Support function.  Adjusts end of heap to provide more memory to	*/
 120:../Library/system/syscalls.c **** /* memory allocator. Simple and dumb with no sanity checks.		*/
 121:../Library/system/syscalls.c **** /*  struct _reent *r	-- re-entrancy structure, used by newlib to 	*/
 122:../Library/system/syscalls.c **** /*			support multiple threads of operation.		*/
 123:../Library/system/syscalls.c **** /*  ptrdiff_t nbytes	-- number of bytes to add.			*/
 124:../Library/system/syscalls.c **** /*  Returns pointer to start of new heap area.				*/
 125:../Library/system/syscalls.c **** /*  Note:  This implementation is not thread safe (despite taking a	*/
 126:../Library/system/syscalls.c **** /* _reent structure as a parameter).  					*/
 127:../Library/system/syscalls.c **** /*  Since _s_r is not used in the current implementation, the following	*/
 128:../Library/system/syscalls.c **** /* messages must be suppressed.						*/
 129:../Library/system/syscalls.c **** 
 130:../Library/system/syscalls.c **** void * _sbrk_r(
 131:../Library/system/syscalls.c ****     struct _reent *_s_r, 
 132:../Library/system/syscalls.c ****     ptrdiff_t nbytes)
 133:../Library/system/syscalls.c **** {
 128              		.loc 1 133 0
 129              		.cfi_startproc
 130              		@ Function supports interworking.
 131              		@ args = 0, pretend = 0, frame = 0
 132              		@ frame_needed = 0, uses_anonymous_args = 0
 133              		@ link register save eliminated.
 134              	.LVL12:
 134:../Library/system/syscalls.c **** 	char  *base;		/*  errno should be set to  ENOMEM on error	*/
 135:../Library/system/syscalls.c **** 
 136:../Library/system/syscalls.c **** 	if (!heap_ptr) {	/*  Initialize if first time through.		*/
 135              		.loc 1 136 0
 136 0038 1C309FE5 		ldr	r3, .L9
 137 003c 002093E5 		ldr	r2, [r3, #0]
 138 0040 000052E3 		cmp	r2, #0
 137:../Library/system/syscalls.c **** 		heap_ptr = end;
 139              		.loc 1 137 0
 140 0044 14209F05 		ldreq	r2, .L9+4
 141 0048 00208305 		streq	r2, [r3, #0]
 138:../Library/system/syscalls.c **** 	}
 139:../Library/system/syscalls.c **** 	base = heap_ptr;	/*  Point to end of heap.			*/
 142              		.loc 1 139 0
 143 004c 000093E5 		ldr	r0, [r3, #0]
 144              	.LVL13:
 140:../Library/system/syscalls.c **** 	heap_ptr += nbytes;	/*  Increase heap.				*/
 145              		.loc 1 140 0
 146 0050 011080E0 		add	r1, r0, r1
 147              	.LVL14:
 148 0054 001083E5 		str	r1, [r3, #0]
 141:../Library/system/syscalls.c **** 	
 142:../Library/system/syscalls.c **** 	return base;		/*  Return pointer to start of new heap area.	*/
 143:../Library/system/syscalls.c **** }
 149              		.loc 1 143 0
 150 0058 1EFF2FE1 		bx	lr
 151              	.L10:
 152              		.align	2
 153              	.L9:
 154 005c 00000000 		.word	.LANCHOR0
 155 0060 00000000 		.word	end
 156              		.cfi_endproc
 157              	.LFE6:
 159              		.bss
 160              		.align	2
 161              		.set	.LANCHOR0,. + 0
 164              	heap_ptr:
 165 0000 00000000 		.space	4
 166              		.text
 167              	.Letext0:
 168              		.file 2 "/opt/local/lib/gcc/arm-elf/4.6.1/include/stddef.h"
 169              		.file 3 "/opt/local/lib/gcc/arm-elf/4.6.1/../../../../arm-elf/include/sys/lock.h"
 170              		.file 4 "/opt/local/lib/gcc/arm-elf/4.6.1/../../../../arm-elf/include/sys/_types.h"
 171              		.file 5 "/opt/local/lib/gcc/arm-elf/4.6.1/../../../../arm-elf/include/sys/reent.h"
 172              		.file 6 "/opt/local/lib/gcc/arm-elf/4.6.1/../../../../arm-elf/include/sys/types.h"
 173              		.file 7 "/opt/local/lib/gcc/arm-elf/4.6.1/../../../../arm-elf/include/sys/stat.h"
 174              		.file 8 "/opt/local/lib/gcc/arm-elf/4.6.1/../../../../arm-elf/include/reent.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 syscalls.c
/var/folders/vb/2fcwf0x52qn_fy1j7_hx1lpr0000gn/T//ccBchRyk.s:5      .text:0000000000000000 $a
/var/folders/vb/2fcwf0x52qn_fy1j7_hx1lpr0000gn/T//ccBchRyk.s:8      .text:0000000000000000 _read_r
/var/folders/vb/2fcwf0x52qn_fy1j7_hx1lpr0000gn/T//ccBchRyk.s:28     .text:0000000000000008 _write_r
/var/folders/vb/2fcwf0x52qn_fy1j7_hx1lpr0000gn/T//ccBchRyk.s:47     .text:0000000000000010 _close_r
/var/folders/vb/2fcwf0x52qn_fy1j7_hx1lpr0000gn/T//ccBchRyk.s:66     .text:0000000000000018 _lseek_r
/var/folders/vb/2fcwf0x52qn_fy1j7_hx1lpr0000gn/T//ccBchRyk.s:85     .text:0000000000000020 _fstat_r
/var/folders/vb/2fcwf0x52qn_fy1j7_hx1lpr0000gn/T//ccBchRyk.s:107    .text:0000000000000030 isatty
/var/folders/vb/2fcwf0x52qn_fy1j7_hx1lpr0000gn/T//ccBchRyk.s:126    .text:0000000000000038 _sbrk_r
/var/folders/vb/2fcwf0x52qn_fy1j7_hx1lpr0000gn/T//ccBchRyk.s:154    .text:000000000000005c $d
/var/folders/vb/2fcwf0x52qn_fy1j7_hx1lpr0000gn/T//ccBchRyk.s:160    .bss:0000000000000000 $d
/var/folders/vb/2fcwf0x52qn_fy1j7_hx1lpr0000gn/T//ccBchRyk.s:164    .bss:0000000000000000 heap_ptr
                     .debug_frame:0000000000000010 $d

UNDEFINED SYMBOLS
end
