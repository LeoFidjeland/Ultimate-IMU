   1              		.file	"main.cpp"
   2              		.text
   3              	.Ltext0:
   4              		.cfi_sections	.debug_frame
   5              		.align	2
   6              		.global	_Z6bootUpv
   8              	_Z6bootUpv:
   9              	.LFB1:
  10              		.file 1 "main.cpp"
   1:main.cpp      **** /*
   2:main.cpp      **** Ultimate IMU Code
   3:main.cpp      **** 
   4:main.cpp      **** Written by Ryan Owens
   5:main.cpp      **** SparkFun Electronics
   6:main.cpp      **** 10/1/10
   7:main.cpp      **** 
   8:main.cpp      **** See code repository for most updated version
   9:main.cpp      **** link
  10:main.cpp      **** 
  11:main.cpp      **** license
  12:main.cpp      **** */
  13:main.cpp      **** #include <stdio.h>
  14:main.cpp      **** #include <stdlib.h>
  15:main.cpp      **** #include <string.h>
  16:main.cpp      **** #include "LPC214x.h"
  17:main.cpp      **** #include "target.h"
  18:main.cpp      **** #include <math.h>
  19:main.cpp      **** //*******************************************************
  20:main.cpp      **** //						C Libraries
  21:main.cpp      **** //*******************************************************
  22:main.cpp      **** extern "C"{
  23:main.cpp      **** #include "main_msc.h"
  24:main.cpp      **** 
  25:main.cpp      **** #include "serial.h"
  26:main.cpp      **** #include "rprintf.h"
  27:main.cpp      **** 
  28:main.cpp      **** #include "timer0.h"
  29:main.cpp      **** #include "timer0ISR.h"
  30:main.cpp      **** #include "timer1.h"
  31:main.cpp      **** 
  32:main.cpp      **** #include "uart0.h"
  33:main.cpp      **** #include "uart0ISR.h"
  34:main.cpp      **** #include "uart1.h"
  35:main.cpp      **** #include "uart1ISR.h"
  36:main.cpp      **** }
  37:main.cpp      **** 
  38:main.cpp      **** //*******************************************************
  39:main.cpp      **** //						C++ Libs
  40:main.cpp      **** //*******************************************************
  41:main.cpp      **** #include "main.h"
  42:main.cpp      **** #include "configuration.h"
  43:main.cpp      **** #include "ADXL345.h"
  44:main.cpp      **** #include "HMC5843.h"
  45:main.cpp      **** #include "ITG3200.h"
  46:main.cpp      **** #include "sensor.h"
  47:main.cpp      **** #include "memory.h"
  48:main.cpp      **** #include "EM408.h"
  49:main.cpp      **** 
  50:main.cpp      **** //*******************************************************
  51:main.cpp      **** //					Core Functions
  52:main.cpp      **** //*******************************************************
  53:main.cpp      **** void bootUp(void);
  54:main.cpp      **** void runTest(void);
  55:main.cpp      **** void initPeripherals(void);
  56:main.cpp      **** 
  57:main.cpp      **** //*******************************************************
  58:main.cpp      **** //					Global Variables
  59:main.cpp      **** //*******************************************************
  60:main.cpp      **** //Version Information.
  61:main.cpp      **** //KEEP THIS UPDATED!
  62:main.cpp      **** char major_version=0;
  63:main.cpp      **** char minor_version=1;
  64:main.cpp      **** 
  65:main.cpp      **** char sensors_updated=0;
  66:main.cpp      **** char sensor_string[70]="";
  67:main.cpp      **** char sensor_log_string[255]="";
  68:main.cpp      **** 
  69:main.cpp      **** cMemory sensorData;
  70:main.cpp      **** cMemory gpsData;
  71:main.cpp      **** cMemory configData;
  72:main.cpp      **** 
  73:main.cpp      **** //*******************************************************
  74:main.cpp      **** //					Main Code
  75:main.cpp      **** //*******************************************************
  76:main.cpp      **** int main (void)
  77:main.cpp      **** {
  78:main.cpp      **** 	//Initialize ARM I/O
  79:main.cpp      **** 	bootUp();			//Init. I/O ports, Comm protocols and interrupts
  80:main.cpp      **** 	if(!memoryBegin())
  81:main.cpp      **** 	{
  82:main.cpp      **** 		rprintf("SD Card Initialization Failed");
  83:main.cpp      **** 
  84:main.cpp      **** 	}
  85:main.cpp      **** 	XBEEon();	//XBee can always be enabled. To get battery savings...take the XBEE module off!
  86:main.cpp      **** 	LEDoff();
  87:main.cpp      **** 
  88:main.cpp      **** 	timer0Init(1000000);
  89:main.cpp      **** 	timer0Match(0, 1000, interruptOnMatch | resetOnMatch);
  90:main.cpp      **** 	//Timer 1 doesn't need to be initialized. It's being used for delay_ms()
  91:main.cpp      **** 	
  92:main.cpp      **** 	//Find out if the device needs to go through the test procedure for QA.
  93:main.cpp      **** 	if(configuration.sd_enabled){
  94:main.cpp      **** 		if(memoryExists("Test.txt")){
  95:main.cpp      **** 			rprintf("Testing...");	
  96:main.cpp      **** 			runTest();
  97:main.cpp      **** 			while(1);
  98:main.cpp      **** 		}
  99:main.cpp      **** 	}
 100:main.cpp      **** 	
 101:main.cpp      **** 	//Get the configuration settings
 102:main.cpp      **** 	if(configuration.sd_enabled){
 103:main.cpp      **** 		if(memoryExists("configuration.txt")){
 104:main.cpp      **** 			readConfigFile(configData);
 105:main.cpp      **** 		}
 106:main.cpp      **** 		//If the configuration file doesn't exist, create it with default settings and reset the device.
 107:main.cpp      **** 		else
 108:main.cpp      **** 		{
 109:main.cpp      **** 			createConfigFile(configData);
 110:main.cpp      **** 			reset();
 111:main.cpp      **** 		}
 112:main.cpp      **** 	}
 113:main.cpp      **** 
 114:main.cpp      **** 	LEDon();
 115:main.cpp      **** 	//Initialize peripherals with settings from configuration file.
 116:main.cpp      **** 	initPeripherals();
 117:main.cpp      **** 	delay_ms(100);	
 118:main.cpp      **** 
 119:main.cpp      **** 	//Create the necessary log files
 120:main.cpp      **** 	if(configuration.log_sensor)sensorData.create("Sensor", ".csv");
 121:main.cpp      **** 	if(configuration.log_gps)gpsData.create("NMEA", ".csv");
 122:main.cpp      **** 
 123:main.cpp      **** 	//Set the UART interrupts to trigger when a single character is received
 124:main.cpp      **** 	uart1RxInt(RX1_TRIG_LEV_0);
 125:main.cpp      **** 	uart0RxInt(RX0_TRIG_LEV_0);
 126:main.cpp      **** 	
 127:main.cpp      **** 	LEDoff();
 128:main.cpp      **** 	VICIntEnable |= INT_UART0;
 129:main.cpp      **** 	if(configuration.log_gps)VICIntEnable |= INT_UART1;
 130:main.cpp      **** 	if(configuration.log_sensor)VICIntEnable |= INT_TIMER0;
 131:main.cpp      **** 	while(1)
 132:main.cpp      **** 	{
 133:main.cpp      **** 		if(timer0IntFlag>10)
 134:main.cpp      **** 		{
 135:main.cpp      **** 			VICIntEnClr |= INT_TIMER0;
 136:main.cpp      **** 			
 137:main.cpp      **** 			if(timer0IntFlag >= 20)LEDon();
 138:main.cpp      **** 			else LEDoff();
 139:main.cpp      **** 			
 140:main.cpp      **** 			timer0IntFlag=0;
 141:main.cpp      **** 			
 142:main.cpp      **** 			accelerometer.update();
 143:main.cpp      **** 			gyro.update();
 144:main.cpp      **** 			compass.update();
 145:main.cpp      **** 			sensors_updated=1;	
 146:main.cpp      **** 			
 147:main.cpp      **** 			VICIntEnable |= INT_TIMER0;
 148:main.cpp      **** 		}
 149:main.cpp      **** 		
 150:main.cpp      **** 		if(uart1MessageComplete)
 151:main.cpp      **** 		{
 152:main.cpp      **** 			VICIntEnClr |= INT_UART1;
 153:main.cpp      **** 			uart1MessageComplete=0;
 154:main.cpp      **** 			
 155:main.cpp      **** 			if(configuration.log_gps){
 156:main.cpp      **** 				strcpy(gps.message, uart1Message);
 157:main.cpp      **** 				gpsData.save(gps.message);
 158:main.cpp      **** 			}
 159:main.cpp      **** 
 160:main.cpp      **** 			if(configuration.output_messages >=2)rprintf("%s\n", gps.message);
 161:main.cpp      **** 			
 162:main.cpp      **** 			VICIntEnable |= INT_UART1;
 163:main.cpp      **** 		}
 164:main.cpp      **** 		
 165:main.cpp      **** 		if(uart0MessageComplete)
 166:main.cpp      **** 		{
 167:main.cpp      **** 			VICIntEnClr |= INT_TIMER0|INT_UART1|INT_UART0;
 168:main.cpp      **** 			uart0MessageComplete=0;
 169:main.cpp      **** 			
 170:main.cpp      **** 			//Save all the current data and close the files.
 171:main.cpp      **** 			if(configuration.log_gps)gpsData.close();
 172:main.cpp      **** 			if(configuration.log_sensor){
 173:main.cpp      **** 				sensorData.save(sensor_log_string);
 174:main.cpp      **** 				strcpy(sensor_log_string, "");
 175:main.cpp      **** 				sensorData.close();
 176:main.cpp      **** 			}
 177:main.cpp      **** 			
 178:main.cpp      **** 			configMenu(configData);
 179:main.cpp      **** 			configData.close();
 180:main.cpp      **** 			
 181:main.cpp      **** 			//Configure the sensors with the new settings
 182:main.cpp      **** 			initPeripherals();
 183:main.cpp      **** 			
 184:main.cpp      **** 			//Create new files, if needed.
 185:main.cpp      **** 			if(configuration.log_sensor)sensorData.create("Sensor", ".csv");
 186:main.cpp      **** 			if(configuration.log_gps)gpsData.create("NMEA", ".csv");			
 187:main.cpp      **** 			
 188:main.cpp      **** 			VICIntEnable |= INT_TIMER0|INT_UART1|INT_UART0;
 189:main.cpp      **** 		}
 190:main.cpp      **** 		
 191:main.cpp      **** 		if(sensors_updated)
 192:main.cpp      **** 		{
 193:main.cpp      **** 			sensors_updated=0;
 194:main.cpp      **** 			
 195:main.cpp      **** 			//If we're not supposed to output the euler angles, just copy the time and sensor values to the 
 196:main.cpp      **** 			//(Sensor Values are in engineering units - g's, degrees/sec, and Ga)
 197:main.cpp      **** 			if(!configuration.output_euler){
 198:main.cpp      **** 				sprintf(sensor_string, "%06ld,%5.2f,%5.2f,%5.2f,%5.2f,%5.2f,%5.2f,%5.2f,%5.2f,%5.2f\n\r",
 199:main.cpp      **** 						millis(),
 200:main.cpp      **** 						gyro.getX(), gyro.getY(), gyro.getZ(),
 201:main.cpp      **** 						accelerometer.getX(), accelerometer.getY(), accelerometer.getZ(),
 202:main.cpp      **** 						compass.getX(), compass.getY(), compass.getZ());
 203:main.cpp      **** 			}
 204:main.cpp      **** 			else{
 205:main.cpp      **** 				//Calculate Euler Angles and tilt compensated heading
 206:main.cpp      **** 				filter.last_time=filter.this_time;
 207:main.cpp      **** 				filter.this_time=millis();	//Get the current number of milliseconds
 208:main.cpp      **** 				//Calculate Interval Time in milliseconds
 209:main.cpp      **** 				filter.interval=filter.this_time-filter.last_time;
 210:main.cpp      **** 				
 211:main.cpp      **** 				//Populate the RwAcc Array
 212:main.cpp      **** 				filter.fillRwAcc(accelerometer.getX(), accelerometer.getY(), accelerometer.getZ());		
 213:main.cpp      **** 				
 214:main.cpp      **** 				//Normalize the Accelerometers gravity vector
 215:main.cpp      **** 				filter.normalizeVector(filter.RwAcc);
 216:main.cpp      **** 				
 217:main.cpp      **** 				//The measurements of the first run get screwed up since we don't have a previous angle
 218:main.cpp      **** 				//to derive the current angle from. So, we skip the calculation on the first time through this 
 219:main.cpp      **** 				if(filter.first_run)
 220:main.cpp      **** 				{
 221:main.cpp      **** 					for(int w=0; w<3; w++)filter.RwGyro[w] = filter.RwAcc[w];
 222:main.cpp      **** 					filter.first_run=0;			
 223:main.cpp      **** 				}
 224:main.cpp      **** 				else
 225:main.cpp      **** 				{
 226:main.cpp      **** 					//If the previous estimated values is too small, don't calc. a new one as the error will be la
 227:main.cpp      **** 					if(filter.RwEst[2] < 0.1)
 228:main.cpp      **** 					{
 229:main.cpp      **** 						for(int w=0; w<3; w++)filter.RwGyro[w]=filter.RwEst[w];
 230:main.cpp      **** 					}
 231:main.cpp      **** 					//Else, find the 'gyro angle' and calculate the weighted average to find attitude of device.
 232:main.cpp      **** 					else
 233:main.cpp      **** 					{
 234:main.cpp      **** 						//Get the current deg/sec from gyroscope.
 235:main.cpp      **** 						filter.x_rate=gyro.getX();	
 236:main.cpp      **** 						filter.y_rate=gyro.getY();
 237:main.cpp      **** 						//find the Angle difference between the last reading and this one.
 238:main.cpp      **** 						filter.x_angle=filter.x_rate*(filter.interval/1000.0);	//degree/sec * seconds == degrees
 239:main.cpp      **** 						filter.y_angle=filter.y_rate*(filter.interval/1000.0);
 240:main.cpp      **** 						
 241:main.cpp      **** 						//Find the current angle based on the previously measured angle
 242:main.cpp      **** 						filter.Axz = atan2(filter.RwEst[0], filter.RwEst[2])*180/PI;	//Get previous angle in degrees
 243:main.cpp      **** 						filter.Axz += filter.x_angle;	//Add the current angle to the previous one to get current angl
 244:main.cpp      **** 						filter.Ayz = atan2(filter.RwEst[1], filter.RwEst[2])*180/PI;
 245:main.cpp      **** 						filter.Ayz += filter.y_angle;
 246:main.cpp      **** 					}
 247:main.cpp      **** 					
 248:main.cpp      **** 					if(filter.RwAcc[2] >=0)filter.signRzGyro=1;
 249:main.cpp      **** 					else filter.signRzGyro=-1;
 250:main.cpp      **** 
 251:main.cpp      **** 					//Use Axz to find RxGyro
 252:main.cpp      **** 					filter.RwGyro[0] = sin(filter.Axz * (PI/180));
 253:main.cpp      **** 					filter.RwGyro[0] /= sqrt(1+cos(filter.Axz * (PI/180))*cos(filter.Axz * (PI/180))
 254:main.cpp      **** 											*tan(filter.Ayz*(PI/180))*tan(filter.Ayz*(PI/180)));
 255:main.cpp      **** 					//Use Ayz to find RyGyro
 256:main.cpp      **** 					filter.RwGyro[1] = sin(filter.Ayz * (PI/180));
 257:main.cpp      **** 					filter.RwGyro[1] /= sqrt(1+cos(filter.Ayz * (PI/180))*cos(filter.Ayz * (PI/180))
 258:main.cpp      **** 											*tan(filter.Axz*(PI/180))*tan(filter.Axz*(PI/180)));
 259:main.cpp      **** 					
 260:main.cpp      **** 					filter.RwGyro[2] = filter.signRzGyro * sqrt(1-pow(filter.RwGyro[0],2)-pow(filter.RwGyro[1],2))
 261:main.cpp      **** 				}
 262:main.cpp      **** 				//Now we have the gravity force vector from both accelerometer and gyro. Combine them using wei
 263:main.cpp      **** 				//to find Rw
 264:main.cpp      **** 				for(int w=0; w<3; w++)
 265:main.cpp      **** 				{
 266:main.cpp      **** 					filter.RwEst[w] = (filter.RwAcc[w] + filter.RwGyro[w] * filter.gyro_weight)/(1+filter.gyro_wei
 267:main.cpp      **** 				}	
 268:main.cpp      **** 				filter.normalizeVector(filter.RwEst);
 269:main.cpp      **** 				
 270:main.cpp      **** 				//filter.AccTheta=atan2(filter.RwAcc[0], filter.RwAcc[2])*180/PI;
 271:main.cpp      **** 				filter.EstAxz=atan2(filter.RwEst[0], filter.RwEst[2])*180/PI;
 272:main.cpp      **** 				filter.EstAyz=atan2(filter.RwEst[1], filter.RwEst[2])*180/PI;
 273:main.cpp      **** 				
 274:main.cpp      **** 				//Now that we have the euler angles, calculate the tilt-compensated heading.
 275:main.cpp      **** 				filter.RwMag[0] = compass.getX();
 276:main.cpp      **** 				filter.RwMag[1] = compass.getY();
 277:main.cpp      **** 				filter.RwMag[2] = compass.getZ();
 278:main.cpp      **** 				
 279:main.cpp      **** 				//Find the X and Y heading values using the tilt information
 280:main.cpp      **** 				filter.x_h = filter.RwMag[0]*cos(filter.EstAyz*(PI/180))+
 281:main.cpp      **** 					filter.RwMag[1]*sin(filter.EstAxz*(PI/180))*sin(filter.EstAyz*(PI/180))-
 282:main.cpp      **** 					filter.RwMag[2]*cos(filter.EstAxz*(PI/180))*sin(filter.EstAyz*(PI/180));
 283:main.cpp      **** 					
 284:main.cpp      **** 				filter.y_h=filter.RwMag[1]*cos(filter.EstAxz*(PI/180))+filter.RwMag[2]*sin(filter.EstAxz*(PI/18
 285:main.cpp      **** 				
 286:main.cpp      **** 				//Find the heading.
 287:main.cpp      **** 				if(filter.x_h < 0)filter.heading = 180 - atan2(filter.y_h, filter.x_h)*180/PI;
 288:main.cpp      **** 				else if((filter.x_h > 0) && (filter.y_h < 0))filter.heading = -atan2(filter.y_h, filter.x_h)*18
 289:main.cpp      **** 				else if((filter.x_h > 0) && (filter.y_h > 0))filter.heading = 360 - atan2(filter.y_h, filter.x_
 290:main.cpp      **** 				else if((filter.x_h == 0)&& (filter.y_h < 0))filter.heading = 90;
 291:main.cpp      **** 				else if((filter.x_h == 0)&& (filter.y_h > 0))filter.heading = 270;
 292:main.cpp      **** 				
 293:main.cpp      **** 				sprintf(sensor_string, "%06ld,%5.2f,%5.2f,%5.2f\n\r", millis(), filter.EstAxz, filter.EstAyz, f
 294:main.cpp      **** 			}
 295:main.cpp      **** 			
 296:main.cpp      **** 			if(configuration.log_sensor){
 297:main.cpp      **** 				//Copy the data to a larger buffer. This keeps the number of 'saves' lower, which results
 298:main.cpp      **** 				//in less overruns in reading the sensors.
 299:main.cpp      **** 				strcat(sensor_log_string, sensor_string);
 300:main.cpp      **** 				if(strlen(sensor_log_string) > 195)
 301:main.cpp      **** 				{
 302:main.cpp      **** 					sensorData.save(sensor_log_string);
 303:main.cpp      **** 					strcpy(sensor_log_string, "");
 304:main.cpp      **** 				}
 305:main.cpp      **** 			}
 306:main.cpp      **** 			
 307:main.cpp      **** 			if(configuration.output_messages == 1 || configuration.output_messages ==3){
 308:main.cpp      **** 				rprintf("%s", sensor_string);
 309:main.cpp      **** 			}
 310:main.cpp      **** 			
 311:main.cpp      **** 		}
 312:main.cpp      **** 		
 313:main.cpp      **** 		//If a USB Cable gets plugged in, stop everything!
 314:main.cpp      **** 		if(IOPIN0 & (1<<23))
 315:main.cpp      **** 		{
 316:main.cpp      **** 			VICIntEnClr = INT_TIMER0 |INT_UART1;	//Stop all running interrupts			
 317:main.cpp      **** 			main_msc();								//Open the mass storage device
 318:main.cpp      **** 			reset();								//Reset to check for new FW
 319:main.cpp      **** 		}
 320:main.cpp      **** 		
 321:main.cpp      **** 	}
 322:main.cpp      **** 	
 323:main.cpp      **** 	
 324:main.cpp      ****     return 0;
 325:main.cpp      **** }
 326:main.cpp      **** 
 327:main.cpp      **** //Usage: bootUp();
 328:main.cpp      **** //Inputs: None
 329:main.cpp      **** //This function initializes the serial port, the SD card, the I/O pins and the interrupts
 330:main.cpp      **** void bootUp(void)
 331:main.cpp      **** {
  11              		.loc 1 331 0
  12              		.cfi_startproc
  13              		@ Function supports interworking.
  14              		@ args = 0, pretend = 0, frame = 0
  15              		@ frame_needed = 0, uses_anonymous_args = 0
  16 0000 04E02DE5 		str	lr, [sp, #-4]!
  17              	.LCFI0:
  18              		.cfi_def_cfa_offset 4
  19              		.cfi_offset 14, -4
 332:main.cpp      **** 	//Initialize UART for RPRINTF
 333:main.cpp      ****     rprintf_devopen(putc_serial0); //Init rprintf
  20              		.loc 1 333 0
  21 0004 68009FE5 		ldr	r0, .L2
  22 0008 FEFFFFEB 		bl	rprintf_devopen
 334:main.cpp      **** 	init_serial0(9600);		
  23              		.loc 1 334 0
  24 000c 960DA0E3 		mov	r0, #9600
  25 0010 FEFFFFEB 		bl	init_serial0
 335:main.cpp      **** 	
 336:main.cpp      **** 	//Initialize I/O Ports and Peripherals
 337:main.cpp      **** 	IODIR0 |= (LED| XBEE_EN);
  26              		.loc 1 337 0
  27 0014 5C309FE5 		ldr	r3, .L2+4
  28 0018 082093E5 		ldr	r2, [r3, #8]
  29 001c 212B82E3 		orr	r2, r2, #33792
  30 0020 082083E5 		str	r2, [r3, #8]
 338:main.cpp      **** 	
 339:main.cpp      ****     //Setup the Interrupts
 340:main.cpp      **** 	//Enable Interrupts
 341:main.cpp      **** 	VPBDIV=1;										// Set PCLK equal to the System Clock	
  31              		.loc 1 341 0
  32 0024 0120A0E3 		mov	r2, #1
  33 0028 753983E2 		add	r3, r3, #1916928
  34 002c 002183E5 		str	r2, [r3, #256]
 342:main.cpp      **** 	VICIntSelect = ~(INT_TIMER0|INT_UART1|INT_UART0);
  35              		.loc 1 342 0
  36 0030 0030E0E3 		mvn	r3, #0
  37 0034 D020E0E3 		mvn	r2, #208
  38 0038 F32F03E5 		str	r2, [r3, #-4083]
 343:main.cpp      **** 	VICVectCntl0 = 0x20 | 4;						//Timer 0 Interrupt
  39              		.loc 1 343 0
  40 003c 2420A0E3 		mov	r2, #36
  41 0040 FF2D03E5 		str	r2, [r3, #-3583]
 344:main.cpp      **** 	VICVectAddr0 = (unsigned int)ISR_Timer0;
  42              		.loc 1 344 0
  43 0044 30209FE5 		ldr	r2, .L2+8
  44 0048 FF2E03E5 		str	r2, [r3, #-3839]
 345:main.cpp      **** 	VICVectCntl1 = (0x20 | 7);
  45              		.loc 1 345 0
  46 004c 2720A0E3 		mov	r2, #39
  47 0050 FB2D03E5 		str	r2, [r3, #-3579]
 346:main.cpp      **** 	VICVectAddr1 = (unsigned int)ISR_UART1;			//UART 1 Interrupt
  48              		.loc 1 346 0
  49 0054 24209FE5 		ldr	r2, .L2+12
  50 0058 FB2E03E5 		str	r2, [r3, #-3835]
 347:main.cpp      **** 	VICVectCntl2 = (0x20 | 6);
  51              		.loc 1 347 0
  52 005c 2620A0E3 		mov	r2, #38
  53 0060 F72D03E5 		str	r2, [r3, #-3575]
 348:main.cpp      **** 	VICVectAddr2 = (unsigned int)ISR_UART0;			//UART 1 Interrupt
  54              		.loc 1 348 0
  55 0064 18209FE5 		ldr	r2, .L2+16
  56 0068 F72E03E5 		str	r2, [r3, #-3831]
 349:main.cpp      **** }
  57              		.loc 1 349 0
  58 006c 04E09DE4 		ldr	lr, [sp], #4
  59 0070 1EFF2FE1 		bx	lr
  60              	.L3:
  61              		.align	2
  62              	.L2:
  63 0074 00000000 		.word	putc_serial0
  64 0078 008002E0 		.word	-536707072
  65 007c 00000000 		.word	ISR_Timer0
  66 0080 00000000 		.word	ISR_UART1
  67 0084 00000000 		.word	ISR_UART0
  68              		.cfi_endproc
  69              	.LFE1:
  71              		.align	2
  72              		.global	_Z5resetv
  74              	_Z5resetv:
  75              	.LFB2:
 350:main.cpp      **** 
 351:main.cpp      **** //Usage: reset();
 352:main.cpp      **** //Inputs: None
 353:main.cpp      **** //Description: Resets the LPC2148
 354:main.cpp      **** void reset(void)
 355:main.cpp      **** {
  76              		.loc 1 355 0
  77              		.cfi_startproc
  78              		@ Function supports interworking.
  79              		@ args = 0, pretend = 0, frame = 0
  80              		@ frame_needed = 0, uses_anonymous_args = 0
  81              		@ link register save eliminated.
 356:main.cpp      ****     // Intentionally fault Watchdog to trigger a reset condition
 357:main.cpp      ****     WDMOD |= 3;
  82              		.loc 1 357 0
  83 0088 0E32A0E3 		mov	r3, #-536870912
  84 008c 002093E5 		ldr	r2, [r3, #0]
  85 0090 032082E3 		orr	r2, r2, #3
  86 0094 002083E5 		str	r2, [r3, #0]
 358:main.cpp      ****     WDFEED = 0xAA;
 359:main.cpp      ****     WDFEED = 0x55;
  87              		.loc 1 359 0
  88 0098 5510A0E3 		mov	r1, #85
 358:main.cpp      ****     WDFEED = 0xAA;
  89              		.loc 1 358 0
  90 009c AA20A0E3 		mov	r2, #170
  91 00a0 082083E5 		str	r2, [r3, #8]
  92              		.loc 1 359 0
  93 00a4 081083E5 		str	r1, [r3, #8]
 360:main.cpp      ****     WDFEED = 0xAA;
  94              		.loc 1 360 0
  95 00a8 082083E5 		str	r2, [r3, #8]
 361:main.cpp      ****     WDFEED = 0x00;
  96              		.loc 1 361 0
  97 00ac 0020A0E3 		mov	r2, #0
  98 00b0 082083E5 		str	r2, [r3, #8]
 362:main.cpp      **** }
  99              		.loc 1 362 0
 100 00b4 1EFF2FE1 		bx	lr
 101              		.cfi_endproc
 102              	.LFE2:
 104              		.align	2
 105              		.global	_Z15initPeripheralsv
 107              	_Z15initPeripheralsv:
 108              	.LFB3:
 363:main.cpp      **** 
 364:main.cpp      **** void initPeripherals(void)
 365:main.cpp      **** {
 109              		.loc 1 365 0
 110              		.cfi_startproc
 111              		@ Function supports interworking.
 112              		@ args = 0, pretend = 0, frame = 0
 113              		@ frame_needed = 0, uses_anonymous_args = 0
 114 00b8 30402DE9 		stmfd	sp!, {r4, r5, lr}
 115              	.LCFI1:
 116              		.cfi_def_cfa_offset 12
 117              		.cfi_offset 14, -4
 118              		.cfi_offset 5, -8
 119              		.cfi_offset 4, -12
 120              	.LBB4:
 366:main.cpp      **** 	//Configure the sensor settings.
 367:main.cpp      **** 	accelerometer.begin(configuration.range_accel);
 121              		.loc 1 367 0
 122 00bc B4409FE5 		ldr	r4, .L9
 123 00c0 B4009FE5 		ldr	r0, .L9+4
 124 00c4 0210D4E5 		ldrb	r1, [r4, #2]	@ zero_extendqisi2
 125 00c8 FEFFFFEB 		bl	_ZN8cADXL3455beginEc
 368:main.cpp      **** 	gyro.begin();
 126              		.loc 1 368 0
 127 00cc AC009FE5 		ldr	r0, .L9+8
 128 00d0 FEFFFFEB 		bl	_ZN8cITG32005beginEv
 369:main.cpp      **** 	compass.begin(configuration.range_compass);	
 129              		.loc 1 369 0
 130 00d4 0310D4E5 		ldrb	r1, [r4, #3]	@ zero_extendqisi2
 131 00d8 A4009FE5 		ldr	r0, .L9+12
 132 00dc FEFFFFEB 		bl	_ZN8cHMC58435beginEc
 370:main.cpp      **** 	
 371:main.cpp      **** 	//set the sensor offsets
 372:main.cpp      **** 	accelerometer.setCalibrationValues(configuration.cal_ax, configuration.cal_ay, configuration.cal_a
 133              		.loc 1 372 0
 134 00e0 101084E2 		add	r1, r4, #16
 135 00e4 060091E8 		ldmia	r1, {r1, r2}
 136 00e8 183094E5 		ldr	r3, [r4, #24]	@ float
 137 00ec 88009FE5 		ldr	r0, .L9+4
 138 00f0 FEFFFFEB 		bl	_ZN8cADXL34520setCalibrationValuesEiif
 373:main.cpp      **** 	gyro.setCalibrationValues(configuration.cal_gx, configuration.cal_gy, configuration.cal_gz);
 139              		.loc 1 373 0
 140 00f4 1C1084E2 		add	r1, r4, #28
 141 00f8 0E0091E8 		ldmia	r1, {r1, r2, r3}
 142 00fc 7C009FE5 		ldr	r0, .L9+8
 143 0100 FEFFFFEB 		bl	_ZN8cITG320020setCalibrationValuesEiii
 374:main.cpp      **** 	
 375:main.cpp      **** 	gps.begin(9600);
 144              		.loc 1 375 0
 145 0104 961DA0E3 		mov	r1, #9600
 146 0108 78009FE5 		ldr	r0, .L9+16
 147 010c FEFFFFEB 		bl	_ZN6cEM4085beginEj
 376:main.cpp      **** 	delay_ms(100);
 148              		.loc 1 376 0
 149 0110 6400A0E3 		mov	r0, #100
 150 0114 FEFFFFEB 		bl	delay_ms
 377:main.cpp      **** 	gps.on();
 151              		.loc 1 377 0
 152 0118 68009FE5 		ldr	r0, .L9+16
 153 011c FEFFFFEB 		bl	_ZN6cEM4082onEv
 378:main.cpp      **** 	delay_ms(500);
 154              		.loc 1 378 0
 155 0120 7D0FA0E3 		mov	r0, #500
 156 0124 FEFFFFEB 		bl	delay_ms
 379:main.cpp      **** 	gps.disable();
 157              		.loc 1 379 0
 158 0128 58009FE5 		ldr	r0, .L9+16
 159 012c FEFFFFEB 		bl	_ZN6cEM4087disableEv
 380:main.cpp      **** 	delay_ms(50);
 160              		.loc 1 380 0
 161 0130 3200A0E3 		mov	r0, #50
 162 0134 FEFFFFEB 		bl	delay_ms
 163              	.LVL0:
 164 0138 034084E2 		add	r4, r4, #3
 381:main.cpp      **** 	for(int i=0; i<6; i++)
 165              		.loc 1 381 0
 166 013c 0050A0E3 		mov	r5, #0
 167              	.LVL1:
 168              	.L7:
 169              	.LBB5:
 382:main.cpp      **** 	{
 383:main.cpp      **** 		if(configuration.gps_messages[i]==1)gps.enable(i, 1);
 170              		.loc 1 383 0
 171 0140 0120F4E5 		ldrb	r2, [r4, #1]!	@ zero_extendqisi2
 172 0144 010052E3 		cmp	r2, #1
 173              		.loc 1 383 0 is_stmt 0 discriminator 1
 174 0148 38009F05 		ldreq	r0, .L9+16
 175 014c 0510A001 		moveq	r1, r5
 176 0150 FEFFFF0B 		bleq	_ZN6cEM4086enableEhh
 177              	.L6:
 384:main.cpp      **** 		delay_ms(50);
 178              		.loc 1 384 0 is_stmt 1
 179 0154 3200A0E3 		mov	r0, #50
 381:main.cpp      **** 	for(int i=0; i<6; i++)
 180              		.loc 1 381 0
 181 0158 015085E2 		add	r5, r5, #1
 182              		.loc 1 384 0
 183 015c FEFFFFEB 		bl	delay_ms
 184              	.LVL2:
 381:main.cpp      **** 	for(int i=0; i<6; i++)
 185              		.loc 1 381 0
 186 0160 060055E3 		cmp	r5, #6
 187 0164 F5FFFF1A 		bne	.L7
 188              	.LBE5:
 385:main.cpp      **** 	}
 386:main.cpp      **** 	
 387:main.cpp      **** 	delay_ms(100);
 189              		.loc 1 387 0
 190 0168 6400A0E3 		mov	r0, #100
 191 016c FEFFFFEB 		bl	delay_ms
 192              	.LBE4:
 388:main.cpp      **** }
 193              		.loc 1 388 0
 194 0170 3040BDE8 		ldmfd	sp!, {r4, r5, lr}
 195 0174 1EFF2FE1 		bx	lr
 196              	.L10:
 197              		.align	2
 198              	.L9:
 199 0178 00000000 		.word	configuration
 200 017c 00000000 		.word	accelerometer
 201 0180 00000000 		.word	gyro
 202 0184 00000000 		.word	compass
 203 0188 00000000 		.word	gps
 204              		.cfi_endproc
 205              	.LFE3:
 207              		.align	2
 208              		.global	_Z7runTestv
 210              	_Z7runTestv:
 211              	.LFB4:
 389:main.cpp      **** 
 390:main.cpp      **** void runTest(void)
 391:main.cpp      **** {
 212              		.loc 1 391 0
 213              		.cfi_startproc
 214              		@ Function supports interworking.
 215              		@ args = 0, pretend = 0, frame = 4
 216              		@ frame_needed = 0, uses_anonymous_args = 0
 217              	.LBB6:
 392:main.cpp      **** 	char value;
 393:main.cpp      **** 	int gpstest;
 394:main.cpp      **** 	
 395:main.cpp      **** 	//Set the UART0 pins to I/O for initial XBee test
 396:main.cpp      **** 	PINSEL0 &= ~((3<<0) | (3<<2));	//Set P0.0 and P0.1 to GPIO
 218              		.loc 1 396 0
 219 018c 58319FE5 		ldr	r3, .L22
 220 0190 002093E5 		ldr	r2, [r3, #0]
 221 0194 0F20C2E3 		bic	r2, r2, #15
 222              	.LBE6:
 391:main.cpp      **** {
 223              		.loc 1 391 0
 224 0198 F1412DE9 		stmfd	sp!, {r0, r4, r5, r6, r7, r8, lr}
 225              	.LCFI2:
 226              		.cfi_def_cfa_offset 28
 227              		.cfi_offset 14, -4
 228              		.cfi_offset 8, -8
 229              		.cfi_offset 7, -12
 230              		.cfi_offset 6, -16
 231              		.cfi_offset 5, -20
 232              		.cfi_offset 4, -24
 233              		.cfi_offset 0, -28
 234              	.LBB9:
 235              		.loc 1 396 0
 236 019c 002083E5 		str	r2, [r3, #0]
 397:main.cpp      **** 	IODIR0 |= (1<<0)|(1<<1);	//Set P0.0 and P0.1 to outputs
 237              		.loc 1 397 0
 238 01a0 48719FE5 		ldr	r7, .L22+4
 239 01a4 083097E5 		ldr	r3, [r7, #8]
 240 01a8 033083E3 		orr	r3, r3, #3
 241              	.LBB7:
 398:main.cpp      **** 	
 399:main.cpp      **** 	for(int blink=0; blink < 10; blink++)
 400:main.cpp      **** 	{
 401:main.cpp      **** 		IOSET0 = (1<<0)|(1<<1);	//Turn on P0.0 and P0.1
 242              		.loc 1 401 0
 243 01ac 0340A0E3 		mov	r4, #3
 244              	.LBE7:
 397:main.cpp      **** 	IODIR0 |= (1<<0)|(1<<1);	//Set P0.0 and P0.1 to outputs
 245              		.loc 1 397 0
 246 01b0 083087E5 		str	r3, [r7, #8]
 247              	.LVL3:
 248 01b4 0A50A0E3 		mov	r5, #10
 249              	.LBB8:
 250              		.loc 1 401 0
 251 01b8 0480A0E1 		mov	r8, r4
 252              	.LVL4:
 253              	.L12:
 402:main.cpp      **** 		delay_ms(50);
 254              		.loc 1 402 0 discriminator 2
 255 01bc 3200A0E3 		mov	r0, #50
 401:main.cpp      **** 		IOSET0 = (1<<0)|(1<<1);	//Turn on P0.0 and P0.1
 256              		.loc 1 401 0 discriminator 2
 257 01c0 048087E5 		str	r8, [r7, #4]
 258              		.loc 1 402 0 discriminator 2
 259 01c4 FEFFFFEB 		bl	delay_ms
 403:main.cpp      **** 		IOCLR0 = (1<<0)|(1<<1);
 260              		.loc 1 403 0 discriminator 2
 261 01c8 0C4087E5 		str	r4, [r7, #12]
 404:main.cpp      **** 		delay_ms(50);
 262              		.loc 1 404 0 discriminator 2
 263 01cc 3200A0E3 		mov	r0, #50
 264 01d0 FEFFFFEB 		bl	delay_ms
 399:main.cpp      **** 	for(int blink=0; blink < 10; blink++)
 265              		.loc 1 399 0 discriminator 2
 266 01d4 015055E2 		subs	r5, r5, #1
 401:main.cpp      **** 		IOSET0 = (1<<0)|(1<<1);	//Turn on P0.0 and P0.1
 267              		.loc 1 401 0 discriminator 2
 268 01d8 10619FE5 		ldr	r6, .L22+4
 399:main.cpp      **** 	for(int blink=0; blink < 10; blink++)
 269              		.loc 1 399 0 discriminator 2
 270 01dc F6FFFF1A 		bne	.L12
 271              	.LBE8:
 405:main.cpp      **** 	}	
 406:main.cpp      **** 	
 407:main.cpp      **** 	//Enable the serial port
 408:main.cpp      **** 	//Initialize UART for RPRINTF
 409:main.cpp      ****     rprintf_devopen(putc_serial0); //Init rprintf
 272              		.loc 1 409 0
 273 01e0 0C019FE5 		ldr	r0, .L22+8
 274 01e4 FEFFFFEB 		bl	rprintf_devopen
 410:main.cpp      **** 	init_serial0(9600);	
 275              		.loc 1 410 0
 276 01e8 960DA0E3 		mov	r0, #9600
 277 01ec FEFFFFEB 		bl	init_serial0
 411:main.cpp      **** 
 412:main.cpp      **** 	//Test the GPS I/O
 413:main.cpp      **** 	IODIR0 &= ~((1<<8)|(1<<9)|(1<<12));	//Set P0.8, P0.9 and P0.12 to inputs
 278              		.loc 1 413 0
 279 01f0 083096E5 		ldr	r3, [r6, #8]
 280 01f4 133CC3E3 		bic	r3, r3, #4864
 281 01f8 083086E5 		str	r3, [r6, #8]
 414:main.cpp      **** 	gpstest = IOPIN0;
 282              		.loc 1 414 0
 283 01fc 003096E5 		ldr	r3, [r6, #0]
 284              	.LVL5:
 415:main.cpp      **** 	gpstest = (gpstest>>8)&0x13;
 285              		.loc 1 415 0
 286 0200 4334A0E1 		mov	r3, r3, asr #8
 287              	.LVL6:
 288 0204 133003E2 		and	r3, r3, #19
 289              	.LVL7:
 416:main.cpp      **** 	if(gpstest != 0x11)
 290              		.loc 1 416 0
 291 0208 110053E3 		cmp	r3, #17
 292 020c 0200000A 		beq	.L13
 417:main.cpp      **** 	{
 418:main.cpp      **** 		rprintf("GPS Failed.");
 293              		.loc 1 418 0
 294 0210 E0009FE5 		ldr	r0, .L22+12
 295 0214 FEFFFFEB 		bl	rprintf
 296              	.LVL8:
 297              	.L14:
 298 0218 FEFFFFEA 		b	.L14
 299              	.LVL9:
 300              	.L13:
 419:main.cpp      **** 		while(1);
 420:main.cpp      **** 	}
 421:main.cpp      **** 	
 422:main.cpp      **** 	//Test the Accelerometer
 423:main.cpp      **** 	accelerometer.begin(1);
 301              		.loc 1 423 0
 302 021c D8009FE5 		ldr	r0, .L22+16
 303 0220 0110A0E3 		mov	r1, #1
 424:main.cpp      **** 	//Get the Device ID from the accelerometer
 425:main.cpp      **** 	value = DEVID;
 304              		.loc 1 425 0
 305 0224 04408DE2 		add	r4, sp, #4
 423:main.cpp      **** 	accelerometer.begin(1);
 306              		.loc 1 423 0
 307 0228 FEFFFFEB 		bl	_ZN8cADXL3455beginEc
 308              	.LVL10:
 309              		.loc 1 425 0
 310 022c 015064E5 		strb	r5, [r4, #-1]!
 311              	.LVL11:
 426:main.cpp      **** 	accelerometer.read(&value, 1);
 312              		.loc 1 426 0
 313 0230 C4009FE5 		ldr	r0, .L22+16
 314 0234 0410A0E1 		mov	r1, r4
 315 0238 0120A0E3 		mov	r2, #1
 316 023c FEFFFFEB 		bl	_ZN8cADXL3454readEPcc
 427:main.cpp      **** 	if(value != 0xE5)
 317              		.loc 1 427 0
 318 0240 0330DDE5 		ldrb	r3, [sp, #3]	@ zero_extendqisi2
 319              	.LVL12:
 320 0244 E50053E3 		cmp	r3, #229
 321              	.LVL13:
 322 0248 0200000A 		beq	.L15
 428:main.cpp      **** 	{
 429:main.cpp      **** 		rprintf("Accel Failed to ping");
 323              		.loc 1 429 0
 324 024c AC009FE5 		ldr	r0, .L22+20
 325 0250 FEFFFFEB 		bl	rprintf
 326              	.LVL14:
 327              	.L16:
 328 0254 FEFFFFEA 		b	.L16
 329              	.LVL15:
 330              	.L15:
 430:main.cpp      **** 		while(1);
 431:main.cpp      **** 	}
 432:main.cpp      **** 	
 433:main.cpp      **** 	//Test the Gyroscope
 434:main.cpp      **** 	gyro.begin();
 331              		.loc 1 434 0
 332 0258 A4009FE5 		ldr	r0, .L22+24
 333 025c FEFFFFEB 		bl	_ZN8cITG32005beginEv
 334              	.LVL16:
 435:main.cpp      **** 	//Get the Device ID from the gyro
 436:main.cpp      **** 	value = WHO_AM_I;
 437:main.cpp      **** 	gyro.read(&value, 1);
 335              		.loc 1 437 0
 336 0260 9C009FE5 		ldr	r0, .L22+24
 337 0264 0410A0E1 		mov	r1, r4
 338 0268 0120A0E3 		mov	r2, #1
 436:main.cpp      **** 	value = WHO_AM_I;
 339              		.loc 1 436 0
 340 026c 0350CDE5 		strb	r5, [sp, #3]
 341              	.LVL17:
 342              		.loc 1 437 0
 343 0270 FEFFFFEB 		bl	_ZN8cITG32004readEPcc
 438:main.cpp      **** 	if((value & 0x68) != 0x68)
 344              		.loc 1 438 0
 345 0274 0330DDE5 		ldrb	r3, [sp, #3]	@ zero_extendqisi2
 346              	.LVL18:
 347 0278 683003E2 		and	r3, r3, #104
 348              	.LVL19:
 349 027c 680053E3 		cmp	r3, #104
 350 0280 0200000A 		beq	.L17
 439:main.cpp      **** 	{
 440:main.cpp      **** 		rprintf("Gyro failed to ping");
 351              		.loc 1 440 0
 352 0284 7C009FE5 		ldr	r0, .L22+28
 353 0288 FEFFFFEB 		bl	rprintf
 354              	.L18:
 355 028c FEFFFFEA 		b	.L18
 356              	.L17:
 441:main.cpp      **** 		while(1);
 442:main.cpp      **** 	}
 443:main.cpp      **** 	
 444:main.cpp      **** 	//Test the compass
 445:main.cpp      **** 	compass.begin(1);
 357              		.loc 1 445 0
 358 0290 74009FE5 		ldr	r0, .L22+32
 359 0294 0110A0E3 		mov	r1, #1
 360 0298 FEFFFFEB 		bl	_ZN8cHMC58435beginEc
 446:main.cpp      **** 	//Get the device ID from the compass
 447:main.cpp      **** 	value = ID_REGA;
 361              		.loc 1 447 0
 362 029c 0A30A0E3 		mov	r3, #10
 448:main.cpp      **** 	compass.read(&value, 1);
 363              		.loc 1 448 0
 364 02a0 64009FE5 		ldr	r0, .L22+32
 365 02a4 0410A0E1 		mov	r1, r4
 366 02a8 0120A0E3 		mov	r2, #1
 447:main.cpp      **** 	value = ID_REGA;
 367              		.loc 1 447 0
 368 02ac 0330CDE5 		strb	r3, [sp, #3]
 369              	.LVL20:
 370              		.loc 1 448 0
 371 02b0 FEFFFFEB 		bl	_ZN8cHMC58434readEPcc
 449:main.cpp      **** 	if(value != 0x48)
 372              		.loc 1 449 0
 373 02b4 0330DDE5 		ldrb	r3, [sp, #3]	@ zero_extendqisi2
 374              	.LVL21:
 375 02b8 480053E3 		cmp	r3, #72
 376              	.LVL22:
 377 02bc 0200000A 		beq	.L19
 450:main.cpp      **** 	{
 451:main.cpp      **** 		rprintf("Compass failed to ping");
 378              		.loc 1 451 0
 379 02c0 48009FE5 		ldr	r0, .L22+36
 380 02c4 FEFFFFEB 		bl	rprintf
 381              	.LVL23:
 382              	.L20:
 383 02c8 FEFFFFEA 		b	.L20
 384              	.LVL24:
 385              	.L19:
 452:main.cpp      **** 		while(1);
 453:main.cpp      **** 	}
 454:main.cpp      **** 	
 455:main.cpp      **** 	rprintf("Pass!");
 386              		.loc 1 455 0
 387 02cc 40009FE5 		ldr	r0, .L22+40
 388 02d0 FEFFFFEB 		bl	rprintf
 389              	.LVL25:
 456:main.cpp      **** 	LEDon();
 390              		.loc 1 456 0
 391 02d4 0239A0E3 		mov	r3, #32768
 392 02d8 043086E5 		str	r3, [r6, #4]
 457:main.cpp      **** 	memoryDelete("Test.txt");
 393              		.loc 1 457 0
 394 02dc 34009FE5 		ldr	r0, .L22+44
 395 02e0 FEFFFFEB 		bl	_Z12memoryDeletePc
 396              	.LBE9:
 458:main.cpp      **** }
 397              		.loc 1 458 0
 398 02e4 F841BDE8 		ldmfd	sp!, {r3, r4, r5, r6, r7, r8, lr}
 399 02e8 1EFF2FE1 		bx	lr
 400              	.L23:
 401              		.align	2
 402              	.L22:
 403 02ec 00C002E0 		.word	-536690688
 404 02f0 008002E0 		.word	-536707072
 405 02f4 00000000 		.word	putc_serial0
 406 02f8 00000000 		.word	.LC0
 407 02fc 00000000 		.word	accelerometer
 408 0300 0C000000 		.word	.LC1
 409 0304 00000000 		.word	gyro
 410 0308 21000000 		.word	.LC2
 411 030c 00000000 		.word	compass
 412 0310 35000000 		.word	.LC3
 413 0314 4C000000 		.word	.LC4
 414 0318 52000000 		.word	.LC5
 415              		.cfi_endproc
 416              	.LFE4:
 418              		.global	__extendsfdf2
 419              		.global	__floatunsidf
 420              		.global	__truncdfsf2
 421              		.global	__ltdf2
 422              		.global	__divdf3
 423              		.global	__muldf3
 424              		.global	__adddf3
 425              		.global	__gedf2
 426              		.global	__floatsidf
 427              		.global	__subdf3
 428              		.global	__gtdf2
 429              		.global	__eqdf2
 430              		.section	.text.startup,"ax",%progbits
 431              		.align	2
 432              		.global	main
 434              	main:
 435              	.LFB0:
  77:main.cpp      **** {
 436              		.loc 1 77 0
 437              		.cfi_startproc
 438              		@ Function supports interworking.
 439              		@ args = 0, pretend = 0, frame = 36
 440              		@ frame_needed = 0, uses_anonymous_args = 0
 441 0000 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 442              	.LCFI3:
 443              		.cfi_def_cfa_offset 36
 444              		.cfi_offset 14, -4
 445              		.cfi_offset 11, -8
 446              		.cfi_offset 10, -12
 447              		.cfi_offset 9, -16
 448              		.cfi_offset 8, -20
 449              		.cfi_offset 7, -24
 450              		.cfi_offset 6, -28
 451              		.cfi_offset 5, -32
 452              		.cfi_offset 4, -36
 453 0004 68D04DE2 		sub	sp, sp, #104
 454              	.LCFI4:
 455              		.cfi_def_cfa_offset 140
 456              	.LBB10:
  79:main.cpp      **** 	bootUp();			//Init. I/O ports, Comm protocols and interrupts
 457              		.loc 1 79 0
 458 0008 FEFFFFEB 		bl	_Z6bootUpv
  80:main.cpp      **** 	if(!memoryBegin())
 459              		.loc 1 80 0
 460 000c FEFFFFEB 		bl	_Z11memoryBeginv
 461 0010 000050E3 		cmp	r0, #0
  82:main.cpp      **** 		rprintf("SD Card Initialization Failed");
 462              		.loc 1 82 0
 463 0014 AC0D9F05 		ldreq	r0, .L95
 464 0018 FEFFFF0B 		bleq	rprintf
 465              	.L25:
  85:main.cpp      **** 	XBEEon();	//XBee can always be enabled. To get battery savings...take the XBEE module off!
 466              		.loc 1 85 0
 467 001c A83D9FE5 		ldr	r3, .L95+4
 468 0020 012BA0E3 		mov	r2, #1024
 469 0024 042083E5 		str	r2, [r3, #4]
  86:main.cpp      **** 	LEDoff();
 470              		.loc 1 86 0
 471 0028 0229A0E3 		mov	r2, #32768
 472 002c 0C2083E5 		str	r2, [r3, #12]
  88:main.cpp      **** 	timer0Init(1000000);
 473              		.loc 1 88 0
 474 0030 980D9FE5 		ldr	r0, .L95+8
  93:main.cpp      **** 	if(configuration.sd_enabled){
 475              		.loc 1 93 0
 476 0034 984D9FE5 		ldr	r4, .L95+12
  88:main.cpp      **** 	timer0Init(1000000);
 477              		.loc 1 88 0
 478 0038 FEFFFFEB 		bl	timer0Init
  89:main.cpp      **** 	timer0Match(0, 1000, interruptOnMatch | resetOnMatch);
 479              		.loc 1 89 0
 480 003c 0000A0E3 		mov	r0, #0
 481 0040 FA1FA0E3 		mov	r1, #1000
 482 0044 0320A0E3 		mov	r2, #3
 483 0048 FEFFFFEB 		bl	timer0Match
  93:main.cpp      **** 	if(configuration.sd_enabled){
 484              		.loc 1 93 0
 485 004c 0A30D4E5 		ldrb	r3, [r4, #10]	@ zero_extendqisi2
 486 0050 000053E3 		cmp	r3, #0
 487 0054 0700000A 		beq	.L26
  94:main.cpp      **** 		if(memoryExists("Test.txt")){
 488              		.loc 1 94 0
 489 0058 780D9FE5 		ldr	r0, .L95+16
 490 005c FEFFFFEB 		bl	_Z12memoryExistsPc
 491 0060 000050E3 		cmp	r0, #0
 492 0064 0300000A 		beq	.L26
  95:main.cpp      **** 			rprintf("Testing...");	
 493              		.loc 1 95 0
 494 0068 6C0D9FE5 		ldr	r0, .L95+20
 495 006c FEFFFFEB 		bl	rprintf
  96:main.cpp      **** 			runTest();
 496              		.loc 1 96 0
 497 0070 FEFFFFEB 		bl	_Z7runTestv
 498              	.L27:
 499 0074 FEFFFFEA 		b	.L27
 500              	.L26:
 102:main.cpp      **** 	if(configuration.sd_enabled){
 501              		.loc 1 102 0
 502 0078 0A30D4E5 		ldrb	r3, [r4, #10]	@ zero_extendqisi2
 503 007c 000053E3 		cmp	r3, #0
 504 0080 0F00000A 		beq	.L28
 103:main.cpp      **** 		if(memoryExists("configuration.txt")){
 505              		.loc 1 103 0
 506 0084 540D9FE5 		ldr	r0, .L95+24
 507 0088 FEFFFFEB 		bl	_Z12memoryExistsPc
 508 008c 50CD9FE5 		ldr	ip, .L95+28
 104:main.cpp      **** 			readConfigFile(configData);
 509              		.loc 1 104 0
 510 0090 10408CE2 		add	r4, ip, #16
 103:main.cpp      **** 		if(memoryExists("configuration.txt")){
 511              		.loc 1 103 0
 512 0094 000050E3 		cmp	r0, #0
 104:main.cpp      **** 			readConfigFile(configData);
 513              		.loc 1 104 0
 514 0098 0F00B4E8 		ldmia	r4!, {r0, r1, r2, r3}
 515 009c 0DE0A0E1 		mov	lr, sp
 516 00a0 0F00AEE8 		stmia	lr!, {r0, r1, r2, r3}
 517 00a4 003094E5 		ldr	r3, [r4, #0]
 518 00a8 00308EE5 		str	r3, [lr, #0]
 519 00ac 0F009CE8 		ldmia	ip, {r0, r1, r2, r3}
 103:main.cpp      **** 		if(memoryExists("configuration.txt")){
 520              		.loc 1 103 0
 521 00b0 0100000A 		beq	.L29
 104:main.cpp      **** 			readConfigFile(configData);
 522              		.loc 1 104 0
 523 00b4 FEFFFFEB 		bl	_Z14readConfigFile7cMemory
 524 00b8 010000EA 		b	.L28
 525              	.L29:
 109:main.cpp      **** 			createConfigFile(configData);
 526              		.loc 1 109 0
 527 00bc FEFFFFEB 		bl	_Z16createConfigFile7cMemory
 110:main.cpp      **** 			reset();
 528              		.loc 1 110 0
 529 00c0 FEFFFFEB 		bl	_Z5resetv
 530              	.L28:
 114:main.cpp      **** 	LEDon();
 531              		.loc 1 114 0
 532 00c4 003D9FE5 		ldr	r3, .L95+4
 533 00c8 0229A0E3 		mov	r2, #32768
 534 00cc 042083E5 		str	r2, [r3, #4]
 120:main.cpp      **** 	if(configuration.log_sensor)sensorData.create("Sensor", ".csv");
 535              		.loc 1 120 0
 536 00d0 FC4C9FE5 		ldr	r4, .L95+12
 116:main.cpp      **** 	initPeripherals();
 537              		.loc 1 116 0
 538 00d4 FEFFFFEB 		bl	_Z15initPeripheralsv
 117:main.cpp      **** 	delay_ms(100);	
 539              		.loc 1 117 0
 540 00d8 6400A0E3 		mov	r0, #100
 541 00dc FEFFFFEB 		bl	delay_ms
 120:main.cpp      **** 	if(configuration.log_sensor)sensorData.create("Sensor", ".csv");
 542              		.loc 1 120 0
 543 00e0 0030D4E5 		ldrb	r3, [r4, #0]	@ zero_extendqisi2
 544 00e4 000053E3 		cmp	r3, #0
 120:main.cpp      **** 	if(configuration.log_sensor)sensorData.create("Sensor", ".csv");
 545              		.loc 1 120 0 is_stmt 0 discriminator 1
 546 00e8 F80C9F15 		ldrne	r0, .L95+32
 547 00ec F81C9F15 		ldrne	r1, .L95+36
 548 00f0 F82C9F15 		ldrne	r2, .L95+40
 549 00f4 FEFFFF1B 		blne	_ZN7cMemory6createEPKcS1_
 550              	.L30:
 121:main.cpp      **** 	if(configuration.log_gps)gpsData.create("NMEA", ".csv");
 551              		.loc 1 121 0 is_stmt 1
 552 00f8 0130D4E5 		ldrb	r3, [r4, #1]	@ zero_extendqisi2
 553 00fc 000053E3 		cmp	r3, #0
 121:main.cpp      **** 	if(configuration.log_gps)gpsData.create("NMEA", ".csv");
 554              		.loc 1 121 0 is_stmt 0 discriminator 1
 555 0100 EC0C9F15 		ldrne	r0, .L95+44
 556 0104 EC1C9F15 		ldrne	r1, .L95+48
 557 0108 E02C9F15 		ldrne	r2, .L95+40
 558 010c FEFFFF1B 		blne	_ZN7cMemory6createEPKcS1_
 559              	.L31:
 124:main.cpp      **** 	uart1RxInt(RX1_TRIG_LEV_0);
 560              		.loc 1 124 0 is_stmt 1
 561 0110 0000A0E3 		mov	r0, #0
 562 0114 FEFFFFEB 		bl	uart1RxInt
 125:main.cpp      **** 	uart0RxInt(RX0_TRIG_LEV_0);
 563              		.loc 1 125 0
 564 0118 0000A0E3 		mov	r0, #0
 565 011c FEFFFFEB 		bl	uart0RxInt
 127:main.cpp      **** 	LEDoff();
 566              		.loc 1 127 0
 567 0120 A43C9FE5 		ldr	r3, .L95+4
 568 0124 0229A0E3 		mov	r2, #32768
 569 0128 0C2083E5 		str	r2, [r3, #12]
 128:main.cpp      **** 	VICIntEnable |= INT_UART0;
 570              		.loc 1 128 0
 571 012c 0030E0E3 		mvn	r3, #0
 572 0130 EF2F13E5 		ldr	r2, [r3, #-4079]
 573 0134 402082E3 		orr	r2, r2, #64
 574 0138 EF2F03E5 		str	r2, [r3, #-4079]
 129:main.cpp      **** 	if(configuration.log_gps)VICIntEnable |= INT_UART1;
 575              		.loc 1 129 0
 576 013c 902C9FE5 		ldr	r2, .L95+12
 577 0140 0110D2E5 		ldrb	r1, [r2, #1]	@ zero_extendqisi2
 578 0144 000051E3 		cmp	r1, #0
 579 0148 EF1F1315 		ldrne	r1, [r3, #-4079]
 580 014c 80108113 		orrne	r1, r1, #128
 581 0150 EF1F0315 		strne	r1, [r3, #-4079]
 130:main.cpp      **** 	if(configuration.log_sensor)VICIntEnable |= INT_TIMER0;
 582              		.loc 1 130 0
 583 0154 0030D2E5 		ldrb	r3, [r2, #0]	@ zero_extendqisi2
 584 0158 000053E3 		cmp	r3, #0
 585 015c 0030E013 		mvnne	r3, #0
 586 0160 EF2F1315 		ldrne	r2, [r3, #-4079]
 587 0164 10208213 		orrne	r2, r2, #16
 588 0168 EF2F0315 		strne	r2, [r3, #-4079]
 589              	.LBB11:
 590              	.LBB12:
 591              	.LBB13:
 592              	.LBB14:
 593              	.LBB15:
 206:main.cpp      **** 				filter.last_time=filter.this_time;
 594              		.loc 1 206 0
 595 016c 884C9FE5 		ldr	r4, .L95+52
 596              	.L87:
 597              	.LBE15:
 598              	.LBE14:
 599              	.LBE13:
 600              	.LBE12:
 133:main.cpp      **** 		if(timer0IntFlag>10)
 601              		.loc 1 133 0
 602 0170 883C9FE5 		ldr	r3, .L95+56
 603 0174 0030D3E5 		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 604 0178 0A0053E3 		cmp	r3, #10
 605 017c 1800009A 		bls	.L34
 135:main.cpp      **** 			VICIntEnClr |= INT_TIMER0;
 606              		.loc 1 135 0
 607 0180 0020E0E3 		mvn	r2, #0
 608 0184 EB1F12E5 		ldr	r1, [r2, #-4075]
 137:main.cpp      **** 			if(timer0IntFlag >= 20)LEDon();
 609              		.loc 1 137 0
 610 0188 130053E3 		cmp	r3, #19
 135:main.cpp      **** 			VICIntEnClr |= INT_TIMER0;
 611              		.loc 1 135 0
 612 018c 101081E3 		orr	r1, r1, #16
 613 0190 343C9FE5 		ldr	r3, .L95+4
 614 0194 EB1F02E5 		str	r1, [r2, #-4075]
 615 0198 0229A0E3 		mov	r2, #32768
 137:main.cpp      **** 			if(timer0IntFlag >= 20)LEDon();
 616              		.loc 1 137 0
 617 019c 04208385 		strhi	r2, [r3, #4]
 138:main.cpp      **** 			else LEDoff();
 618              		.loc 1 138 0
 619 01a0 0C208395 		strls	r2, [r3, #12]
 140:main.cpp      **** 			timer0IntFlag=0;
 620              		.loc 1 140 0
 621 01a4 543C9FE5 		ldr	r3, .L95+56
 622 01a8 0020A0E3 		mov	r2, #0
 623 01ac 0020C3E5 		strb	r2, [r3, #0]
 142:main.cpp      **** 			accelerometer.update();
 624              		.loc 1 142 0
 625 01b0 4C0C9FE5 		ldr	r0, .L95+60
 626 01b4 FEFFFFEB 		bl	_ZN8cADXL3456updateEv
 143:main.cpp      **** 			gyro.update();
 627              		.loc 1 143 0
 628 01b8 480C9FE5 		ldr	r0, .L95+64
 629 01bc FEFFFFEB 		bl	_ZN8cITG32006updateEv
 144:main.cpp      **** 			compass.update();
 630              		.loc 1 144 0
 631 01c0 440C9FE5 		ldr	r0, .L95+68
 632 01c4 FEFFFFEB 		bl	_ZN8cHMC58436updateEv
 145:main.cpp      **** 			sensors_updated=1;	
 633              		.loc 1 145 0
 634 01c8 140C9FE5 		ldr	r0, .L95+28
 635 01cc 0130A0E3 		mov	r3, #1
 636 01d0 6C30C0E5 		strb	r3, [r0, #108]
 147:main.cpp      **** 			VICIntEnable |= INT_TIMER0;
 637              		.loc 1 147 0
 638 01d4 0030E0E3 		mvn	r3, #0
 639 01d8 EF2F13E5 		ldr	r2, [r3, #-4079]
 640 01dc 102082E3 		orr	r2, r2, #16
 641 01e0 EF2F03E5 		str	r2, [r3, #-4079]
 642              	.L34:
 150:main.cpp      **** 		if(uart1MessageComplete)
 643              		.loc 1 150 0
 644 01e4 243C9FE5 		ldr	r3, .L95+72
 645 01e8 0020D3E5 		ldrb	r2, [r3, #0]	@ zero_extendqisi2
 646 01ec 000052E3 		cmp	r2, #0
 647 01f0 1800000A 		beq	.L37
 152:main.cpp      **** 			VICIntEnClr |= INT_UART1;
 648              		.loc 1 152 0
 649 01f4 0020E0E3 		mvn	r2, #0
 650 01f8 EB1F12E5 		ldr	r1, [r2, #-4075]
 651 01fc 801081E3 		orr	r1, r1, #128
 652 0200 EB1F02E5 		str	r1, [r2, #-4075]
 155:main.cpp      **** 			if(configuration.log_gps){
 653              		.loc 1 155 0
 654 0204 C85B9FE5 		ldr	r5, .L95+12
 153:main.cpp      **** 			uart1MessageComplete=0;
 655              		.loc 1 153 0
 656 0208 0020A0E3 		mov	r2, #0
 657 020c 0020C3E5 		strb	r2, [r3, #0]
 155:main.cpp      **** 			if(configuration.log_gps){
 658              		.loc 1 155 0
 659 0210 0130D5E5 		ldrb	r3, [r5, #1]	@ zero_extendqisi2
 660 0214 020053E1 		cmp	r3, r2
 661 0218 0500000A 		beq	.L38
 156:main.cpp      **** 				strcpy(gps.message, uart1Message);
 662              		.loc 1 156 0
 663 021c F01B9FE5 		ldr	r1, .L95+76
 664 0220 F00B9FE5 		ldr	r0, .L95+80
 665 0224 FEFFFFEB 		bl	strcpy
 157:main.cpp      **** 				gpsData.save(gps.message);
 666              		.loc 1 157 0
 667 0228 C40B9FE5 		ldr	r0, .L95+44
 668 022c E41B9FE5 		ldr	r1, .L95+80
 669 0230 FEFFFFEB 		bl	_ZN7cMemory4saveEPc
 670              	.L38:
 160:main.cpp      **** 			if(configuration.output_messages >=2)rprintf("%s\n", gps.message);
 671              		.loc 1 160 0
 672 0234 0C30D5E5 		ldrb	r3, [r5, #12]	@ zero_extendqisi2
 673 0238 010053E3 		cmp	r3, #1
 160:main.cpp      **** 			if(configuration.output_messages >=2)rprintf("%s\n", gps.message);
 674              		.loc 1 160 0 is_stmt 0 discriminator 1
 675 023c D80B9F85 		ldrhi	r0, .L95+84
 676 0240 D01B9F85 		ldrhi	r1, .L95+80
 677 0244 FEFFFF8B 		blhi	rprintf
 678              	.L39:
 162:main.cpp      **** 			VICIntEnable |= INT_UART1;
 679              		.loc 1 162 0 is_stmt 1
 680 0248 0030E0E3 		mvn	r3, #0
 681 024c EF2F13E5 		ldr	r2, [r3, #-4079]
 682 0250 802082E3 		orr	r2, r2, #128
 683 0254 EF2F03E5 		str	r2, [r3, #-4079]
 684              	.L37:
 165:main.cpp      **** 		if(uart0MessageComplete)
 685              		.loc 1 165 0
 686 0258 C03B9FE5 		ldr	r3, .L95+88
 687 025c 0020D3E5 		ldrb	r2, [r3, #0]	@ zero_extendqisi2
 688 0260 000052E3 		cmp	r2, #0
 689 0264 3200000A 		beq	.L40
 167:main.cpp      **** 			VICIntEnClr |= INT_TIMER0|INT_UART1|INT_UART0;
 690              		.loc 1 167 0
 691 0268 0020E0E3 		mvn	r2, #0
 692 026c EB1F12E5 		ldr	r1, [r2, #-4075]
 693 0270 D01081E3 		orr	r1, r1, #208
 694 0274 EB1F02E5 		str	r1, [r2, #-4075]
 171:main.cpp      **** 			if(configuration.log_gps)gpsData.close();
 695              		.loc 1 171 0
 696 0278 545B9FE5 		ldr	r5, .L95+12
 168:main.cpp      **** 			uart0MessageComplete=0;
 697              		.loc 1 168 0
 698 027c 0020A0E3 		mov	r2, #0
 699 0280 0020C3E5 		strb	r2, [r3, #0]
 171:main.cpp      **** 			if(configuration.log_gps)gpsData.close();
 700              		.loc 1 171 0
 701 0284 0130D5E5 		ldrb	r3, [r5, #1]	@ zero_extendqisi2
 702 0288 020053E1 		cmp	r3, r2
 171:main.cpp      **** 			if(configuration.log_gps)gpsData.close();
 703              		.loc 1 171 0 is_stmt 0 discriminator 1
 704 028c 600B9F15 		ldrne	r0, .L95+44
 705 0290 FEFFFF1B 		blne	_ZN7cMemory5closeEv
 706              	.L41:
 172:main.cpp      **** 			if(configuration.log_sensor){
 707              		.loc 1 172 0 is_stmt 1
 708 0294 0030D5E5 		ldrb	r3, [r5, #0]	@ zero_extendqisi2
 709 0298 000053E3 		cmp	r3, #0
 710 029c 0700000A 		beq	.L42
 173:main.cpp      **** 				sensorData.save(sensor_log_string);
 711              		.loc 1 173 0
 712 02a0 400B9FE5 		ldr	r0, .L95+32
 713 02a4 491080E2 		add	r1, r0, #73
 714 02a8 FEFFFFEB 		bl	_ZN7cMemory4saveEPc
 174:main.cpp      **** 				strcpy(sensor_log_string, "");
 715              		.loc 1 174 0
 716 02ac 700B9FE5 		ldr	r0, .L95+92
 717 02b0 701B9FE5 		ldr	r1, .L95+96
 718 02b4 FEFFFFEB 		bl	strcpy
 175:main.cpp      **** 				sensorData.close();
 719              		.loc 1 175 0
 720 02b8 280B9FE5 		ldr	r0, .L95+32
 721 02bc FEFFFFEB 		bl	_ZN7cMemory5closeEv
 722              	.L42:
 178:main.cpp      **** 			configMenu(configData);
 723              		.loc 1 178 0
 724 02c0 645B9FE5 		ldr	r5, .L95+100
 725 02c4 0F00B5E8 		ldmia	r5!, {r0, r1, r2, r3}
 726 02c8 0DC0A0E1 		mov	ip, sp
 727 02cc 0F00ACE8 		stmia	ip!, {r0, r1, r2, r3}
 728 02d0 003095E5 		ldr	r3, [r5, #0]
 729 02d4 00308CE5 		str	r3, [ip, #0]
 730 02d8 20C045E2 		sub	ip, r5, #32
 731 02dc 0F009CE8 		ldmia	ip, {r0, r1, r2, r3}
 185:main.cpp      **** 			if(configuration.log_sensor)sensorData.create("Sensor", ".csv");
 732              		.loc 1 185 0
 733 02e0 EC6A9FE5 		ldr	r6, .L95+12
 178:main.cpp      **** 			configMenu(configData);
 734              		.loc 1 178 0
 735 02e4 FEFFFFEB 		bl	_Z10configMenu7cMemory
 179:main.cpp      **** 			configData.close();
 736              		.loc 1 179 0
 737 02e8 200045E2 		sub	r0, r5, #32
 738 02ec FEFFFFEB 		bl	_ZN7cMemory5closeEv
 182:main.cpp      **** 			initPeripherals();
 739              		.loc 1 182 0
 740 02f0 FEFFFFEB 		bl	_Z15initPeripheralsv
 185:main.cpp      **** 			if(configuration.log_sensor)sensorData.create("Sensor", ".csv");
 741              		.loc 1 185 0
 742 02f4 0030D6E5 		ldrb	r3, [r6, #0]	@ zero_extendqisi2
 743 02f8 000053E3 		cmp	r3, #0
 185:main.cpp      **** 			if(configuration.log_sensor)sensorData.create("Sensor", ".csv");
 744              		.loc 1 185 0 is_stmt 0 discriminator 1
 745 02fc 04008512 		addne	r0, r5, #4
 746 0300 E41A9F15 		ldrne	r1, .L95+36
 747 0304 E42A9F15 		ldrne	r2, .L95+40
 748 0308 FEFFFF1B 		blne	_ZN7cMemory6createEPKcS1_
 749              	.L43:
 186:main.cpp      **** 			if(configuration.log_gps)gpsData.create("NMEA", ".csv");			
 750              		.loc 1 186 0 is_stmt 1
 751 030c 0130D6E5 		ldrb	r3, [r6, #1]	@ zero_extendqisi2
 752 0310 000053E3 		cmp	r3, #0
 186:main.cpp      **** 			if(configuration.log_gps)gpsData.create("NMEA", ".csv");			
 753              		.loc 1 186 0 is_stmt 0 discriminator 1
 754 0314 D80A9F15 		ldrne	r0, .L95+44
 755 0318 D81A9F15 		ldrne	r1, .L95+48
 756 031c CC2A9F15 		ldrne	r2, .L95+40
 757 0320 FEFFFF1B 		blne	_ZN7cMemory6createEPKcS1_
 758              	.L44:
 188:main.cpp      **** 			VICIntEnable |= INT_TIMER0|INT_UART1|INT_UART0;
 759              		.loc 1 188 0 is_stmt 1
 760 0324 0030E0E3 		mvn	r3, #0
 761 0328 EF2F13E5 		ldr	r2, [r3, #-4079]
 762 032c D02082E3 		orr	r2, r2, #208
 763 0330 EF2F03E5 		str	r2, [r3, #-4079]
 764              	.L40:
 765              	.LBB29:
 191:main.cpp      **** 		if(sensors_updated)
 766              		.loc 1 191 0
 767 0334 A80A9FE5 		ldr	r0, .L95+28
 768 0338 6C30D0E5 		ldrb	r3, [r0, #108]	@ zero_extendqisi2
 769 033c 000053E3 		cmp	r3, #0
 770 0340 9602000A 		beq	.L45
 771              	.LBB28:
 772              	.LBB25:
 197:main.cpp      **** 			if(!configuration.output_euler){
 773              		.loc 1 197 0
 774 0344 883A9FE5 		ldr	r3, .L95+12
 775 0348 0B30D3E5 		ldrb	r3, [r3, #11]	@ zero_extendqisi2
 776              	.LBE25:
 193:main.cpp      **** 			sensors_updated=0;
 777              		.loc 1 193 0
 778 034c 0050A0E3 		mov	r5, #0
 779              	.LBB26:
 197:main.cpp      **** 			if(!configuration.output_euler){
 780              		.loc 1 197 0
 781 0350 050053E1 		cmp	r3, r5
 782              	.LBE26:
 193:main.cpp      **** 			sensors_updated=0;
 783              		.loc 1 193 0
 784 0354 6C50C0E5 		strb	r5, [r0, #108]
 785              	.LBB27:
 197:main.cpp      **** 			if(!configuration.output_euler){
 786              		.loc 1 197 0
 787 0358 4A00001A 		bne	.L46
 202:main.cpp      **** 						compass.getX(), compass.getY(), compass.getZ());
 788              		.loc 1 202 0
 789 035c FEFFFFEB 		bl	millis
 790 0360 0020A0E1 		mov	r2, r0
 200:main.cpp      **** 						gyro.getX(), gyro.getY(), gyro.getZ(),
 791              		.loc 1 200 0
 792 0364 9C0A9FE5 		ldr	r0, .L95+64
 793 0368 44208DE5 		str	r2, [sp, #68]
 794 036c FEFFFFEB 		bl	_ZN8cITG32004getXEv
 795 0370 0050A0E1 		mov	r5, r0
 796 0374 8C0A9FE5 		ldr	r0, .L95+64
 797 0378 FEFFFFEB 		bl	_ZN8cITG32004getYEv
 798 037c 0070A0E1 		mov	r7, r0
 799 0380 800A9FE5 		ldr	r0, .L95+64
 800 0384 FEFFFFEB 		bl	_ZN8cITG32004getZEv
 801 0388 0080A0E1 		mov	r8, r0
 202:main.cpp      **** 						compass.getX(), compass.getY(), compass.getZ());
 802              		.loc 1 202 0
 803 038c 700A9FE5 		ldr	r0, .L95+60
 804 0390 FEFFFFEB 		bl	_ZN8cADXL3454getXEv
 805 0394 48008DE5 		str	r0, [sp, #72]
 806 0398 4C108DE5 		str	r1, [sp, #76]
 807 039c 600A9FE5 		ldr	r0, .L95+60
 808 03a0 FEFFFFEB 		bl	_ZN8cADXL3454getYEv
 809 03a4 50008DE5 		str	r0, [sp, #80]
 810 03a8 54108DE5 		str	r1, [sp, #84]
 811 03ac 500A9FE5 		ldr	r0, .L95+60
 812 03b0 FEFFFFEB 		bl	_ZN8cADXL3454getZEv
 813 03b4 58008DE5 		str	r0, [sp, #88]
 814 03b8 5C108DE5 		str	r1, [sp, #92]
 815 03bc 480A9FE5 		ldr	r0, .L95+68
 816 03c0 FEFFFFEB 		bl	_ZN8cHMC58434getXEv
 817 03c4 00A0A0E1 		mov	sl, r0
 818 03c8 3C0A9FE5 		ldr	r0, .L95+68
 819 03cc FEFFFFEB 		bl	_ZN8cHMC58434getYEv
 820 03d0 0090A0E1 		mov	r9, r0
 821 03d4 300A9FE5 		ldr	r0, .L95+68
 822 03d8 FEFFFFEB 		bl	_ZN8cHMC58434getZEv
 823 03dc 00B0A0E1 		mov	fp, r0
 824 03e0 0500A0E1 		mov	r0, r5
 825 03e4 FEFFFFEB 		bl	__extendsfdf2
 826 03e8 0060A0E1 		mov	r6, r0
 827 03ec 0700A0E1 		mov	r0, r7
 828 03f0 0150A0E1 		mov	r5, r1
 829 03f4 FEFFFFEB 		bl	__extendsfdf2
 830 03f8 03008DE9 		stmib	sp, {r0-r1}
 831 03fc 0800A0E1 		mov	r0, r8
 832 0400 FEFFFFEB 		bl	__extendsfdf2
 833 0404 0C008DE5 		str	r0, [sp, #12]
 834 0408 10108DE5 		str	r1, [sp, #16]
 835 040c 48108DE2 		add	r1, sp, #72
 836 0410 030091E8 		ldmia	r1, {r0-r1}
 837 0414 14008DE5 		str	r0, [sp, #20]
 838 0418 18108DE5 		str	r1, [sp, #24]
 839 041c 50108DE2 		add	r1, sp, #80
 840 0420 030091E8 		ldmia	r1, {r0-r1}
 841 0424 1C008DE5 		str	r0, [sp, #28]
 842 0428 20108DE5 		str	r1, [sp, #32]
 843 042c 58108DE2 		add	r1, sp, #88
 844 0430 030091E8 		ldmia	r1, {r0-r1}
 845 0434 24008DE5 		str	r0, [sp, #36]
 846 0438 28108DE5 		str	r1, [sp, #40]
 847 043c 0A00A0E1 		mov	r0, sl
 848 0440 FEFFFFEB 		bl	__extendsfdf2
 849 0444 2C008DE5 		str	r0, [sp, #44]
 850 0448 30108DE5 		str	r1, [sp, #48]
 851 044c 0900A0E1 		mov	r0, r9
 852 0450 FEFFFFEB 		bl	__extendsfdf2
 853 0454 34008DE5 		str	r0, [sp, #52]
 854 0458 38108DE5 		str	r1, [sp, #56]
 855 045c 0B00A0E1 		mov	r0, fp
 856 0460 FEFFFFEB 		bl	__extendsfdf2
 857 0464 0630A0E1 		mov	r3, r6
 858 0468 3C008DE5 		str	r0, [sp, #60]
 859 046c 40108DE5 		str	r1, [sp, #64]
 860 0470 44209DE5 		ldr	r2, [sp, #68]
 861 0474 B4199FE5 		ldr	r1, .L95+104
 862 0478 B4099FE5 		ldr	r0, .L95+108
 863 047c 00508DE5 		str	r5, [sp, #0]
 864 0480 FEFFFFEB 		bl	sprintf
 865 0484 2D0200EA 		b	.L47
 866              	.L46:
 867              	.LBB24:
 206:main.cpp      **** 				filter.last_time=filter.this_time;
 868              		.loc 1 206 0
 869 0488 A03094E5 		ldr	r3, [r4, #160]
 870 048c 9C3084E5 		str	r3, [r4, #156]
 207:main.cpp      **** 				filter.this_time=millis();	//Get the current number of milliseconds
 871              		.loc 1 207 0
 872 0490 FEFFFFEB 		bl	millis
 209:main.cpp      **** 				filter.interval=filter.this_time-filter.last_time;
 873              		.loc 1 209 0
 874 0494 9C3094E5 		ldr	r3, [r4, #156]
 207:main.cpp      **** 				filter.this_time=millis();	//Get the current number of milliseconds
 875              		.loc 1 207 0
 876 0498 A00084E5 		str	r0, [r4, #160]
 209:main.cpp      **** 				filter.interval=filter.this_time-filter.last_time;
 877              		.loc 1 209 0
 878 049c 000063E0 		rsb	r0, r3, r0
 879 04a0 FEFFFFEB 		bl	__floatunsidf
 880 04a4 A40084E5 		str	r0, [r4, #164]
 881 04a8 A81084E5 		str	r1, [r4, #168]
 212:main.cpp      **** 				filter.fillRwAcc(accelerometer.getX(), accelerometer.getY(), accelerometer.getZ());		
 882              		.loc 1 212 0
 883 04ac 50099FE5 		ldr	r0, .L95+60
 884 04b0 FEFFFFEB 		bl	_ZN8cADXL3454getXEv
 885 04b4 0060A0E1 		mov	r6, r0
 886 04b8 44099FE5 		ldr	r0, .L95+60
 887 04bc 0170A0E1 		mov	r7, r1
 888 04c0 FEFFFFEB 		bl	_ZN8cADXL3454getYEv
 889 04c4 0080A0E1 		mov	r8, r0
 890 04c8 34099FE5 		ldr	r0, .L95+60
 891 04cc 0190A0E1 		mov	r9, r1
 892 04d0 FEFFFFEB 		bl	_ZN8cADXL3454getZEv
 893 04d4 00A0A0E1 		mov	sl, r0
 894 04d8 01B0A0E1 		mov	fp, r1
 895 04dc 0600A0E1 		mov	r0, r6
 896 04e0 0710A0E1 		mov	r1, r7
 897 04e4 FEFFFFEB 		bl	__truncdfsf2
 898 04e8 0910A0E1 		mov	r1, r9
 899 04ec 0060A0E1 		mov	r6, r0
 900 04f0 0800A0E1 		mov	r0, r8
 901 04f4 FEFFFFEB 		bl	__truncdfsf2
 902 04f8 0B10A0E1 		mov	r1, fp
 903 04fc 0070A0E1 		mov	r7, r0
 904 0500 0A00A0E1 		mov	r0, sl
 905 0504 FEFFFFEB 		bl	__truncdfsf2
 906 0508 0610A0E1 		mov	r1, r6
 907 050c 0030A0E1 		mov	r3, r0
 908 0510 0720A0E1 		mov	r2, r7
 909 0514 E0089FE5 		ldr	r0, .L95+52
 910 0518 FEFFFFEB 		bl	_ZN7cSensor9fillRwAccEfff
 215:main.cpp      **** 				filter.normalizeVector(filter.RwAcc);
 911              		.loc 1 215 0
 912 051c D8089FE5 		ldr	r0, .L95+52
 913 0520 181080E2 		add	r1, r0, #24
 914 0524 FEFFFFEB 		bl	_ZN7cSensor15normalizeVectorEPd
 915              	.LBB16:
 219:main.cpp      **** 				if(filter.first_run)
 916              		.loc 1 219 0
 917 0528 E430D4E5 		ldrb	r3, [r4, #228]	@ zero_extendqisi2
 918 052c 000053E3 		cmp	r3, #0
 919 0530 0D00000A 		beq	.L48
 920              	.LBB17:
 921              	.LBB18:
 221:main.cpp      **** 					for(int w=0; w<3; w++)filter.RwGyro[w] = filter.RwAcc[w];
 922              		.loc 1 221 0
 923 0534 183084E2 		add	r3, r4, #24
 924 0538 0C0093E8 		ldmia	r3, {r2-r3}
 925 053c 302084E5 		str	r2, [r4, #48]
 926 0540 343084E5 		str	r3, [r4, #52]
 927              	.LVL26:
 928 0544 203084E2 		add	r3, r4, #32
 929 0548 0C0093E8 		ldmia	r3, {r2-r3}
 930 054c 382084E5 		str	r2, [r4, #56]
 931 0550 3C3084E5 		str	r3, [r4, #60]
 932              	.LVL27:
 933 0554 283084E2 		add	r3, r4, #40
 934 0558 0C0093E8 		ldmia	r3, {r2-r3}
 935              	.LBE18:
 222:main.cpp      **** 					filter.first_run=0;			
 936              		.loc 1 222 0
 937 055c E450C4E5 		strb	r5, [r4, #228]
 938              	.LBB19:
 221:main.cpp      **** 					for(int w=0; w<3; w++)filter.RwGyro[w] = filter.RwAcc[w];
 939              		.loc 1 221 0
 940 0560 402084E5 		str	r2, [r4, #64]
 941 0564 443084E5 		str	r3, [r4, #68]
 942              	.LVL28:
 943 0568 D90000EA 		b	.L49
 944              	.LVL29:
 945              	.L48:
 946              	.LBE19:
 947              	.LBE17:
 948              	.LBB20:
 949              	.LBB21:
 227:main.cpp      **** 					if(filter.RwEst[2] < 0.1)
 950              		.loc 1 227 0
 951 056c 101084E2 		add	r1, r4, #16
 952 0570 030091E8 		ldmia	r1, {r0-r1}
 953 0574 BC289FE5 		ldr	r2, .L95+112
 954 0578 BC389FE5 		ldr	r3, .L95+116
 955 057c FEFFFFEB 		bl	__ltdf2
 956 0580 000050E3 		cmp	r0, #0
 957              	.LVL30:
 958              	.LBB22:
 229:main.cpp      **** 						for(int w=0; w<3; w++)filter.RwGyro[w]=filter.RwEst[w];
 959              		.loc 1 229 0
 960 0584 083084B2 		addlt	r3, r4, #8
 961 0588 0C0093B8 		ldmltia	r3, {r2-r3}
 962 058c 382084B5 		strlt	r2, [r4, #56]
 963 0590 3C3084B5 		strlt	r3, [r4, #60]
 964              	.LVL31:
 965 0594 103084B2 		addlt	r3, r4, #16
 966 0598 0C0093B8 		ldmltia	r3, {r2-r3}
 967 059c 402084B5 		strlt	r2, [r4, #64]
 968 05a0 443084B5 		strlt	r3, [r4, #68]
 969              	.LVL32:
 970 05a4 3F0000BA 		blt	.L52
 971              	.LVL33:
 972              	.L88:
 973              	.LBE22:
 235:main.cpp      **** 						filter.x_rate=gyro.getX();	
 974              		.loc 1 235 0
 975 05a8 58089FE5 		ldr	r0, .L95+64
 976 05ac FEFFFFEB 		bl	_ZN8cITG32004getXEv
 977 05b0 FEFFFFEB 		bl	__extendsfdf2
 978 05b4 B40084E5 		str	r0, [r4, #180]
 979 05b8 B81084E5 		str	r1, [r4, #184]
 236:main.cpp      **** 						filter.y_rate=gyro.getY();
 980              		.loc 1 236 0
 981 05bc 44089FE5 		ldr	r0, .L95+64
 982 05c0 FEFFFFEB 		bl	_ZN8cITG32004getYEv
 983 05c4 FEFFFFEB 		bl	__extendsfdf2
 984 05c8 0060A0E1 		mov	r6, r0
 985 05cc 0170A0E1 		mov	r7, r1
 238:main.cpp      **** 						filter.x_angle=filter.x_rate*(filter.interval/1000.0);	//degree/sec * seconds == degrees
 986              		.loc 1 238 0
 987 05d0 68289FE5 		ldr	r2, .L95+120
 988 05d4 A41084E2 		add	r1, r4, #164
 989 05d8 030091E8 		ldmia	r1, {r0-r1}
 990 05dc 0030A0E3 		mov	r3, #0
 236:main.cpp      **** 						filter.y_rate=gyro.getY();
 991              		.loc 1 236 0
 992 05e0 C46084E5 		str	r6, [r4, #196]
 993 05e4 C87084E5 		str	r7, [r4, #200]
 238:main.cpp      **** 						filter.x_angle=filter.x_rate*(filter.interval/1000.0);	//degree/sec * seconds == degrees
 994              		.loc 1 238 0
 995 05e8 FEFFFFEB 		bl	__divdf3
 996 05ec 0080A0E1 		mov	r8, r0
 997 05f0 0190A0E1 		mov	r9, r1
 998 05f4 0820A0E1 		mov	r2, r8
 999 05f8 B41084E2 		add	r1, r4, #180
 1000 05fc 030091E8 		ldmia	r1, {r0-r1}
 1001 0600 0930A0E1 		mov	r3, r9
 1002 0604 FEFFFFEB 		bl	__muldf3
 239:main.cpp      **** 						filter.y_angle=filter.y_rate*(filter.interval/1000.0);
 1003              		.loc 1 239 0
 1004 0608 0820A0E1 		mov	r2, r8
 238:main.cpp      **** 						filter.x_angle=filter.x_rate*(filter.interval/1000.0);	//degree/sec * seconds == degrees
 1005              		.loc 1 238 0
 1006 060c AC0084E5 		str	r0, [r4, #172]
 1007 0610 B01084E5 		str	r1, [r4, #176]
 239:main.cpp      **** 						filter.y_angle=filter.y_rate*(filter.interval/1000.0);
 1008              		.loc 1 239 0
 1009 0614 0930A0E1 		mov	r3, r9
 1010 0618 0600A0E1 		mov	r0, r6
 1011 061c 0710A0E1 		mov	r1, r7
 1012 0620 FEFFFFEB 		bl	__muldf3
 242:main.cpp      **** 						filter.Axz = atan2(filter.RwEst[0], filter.RwEst[2])*180/PI;	//Get previous angle in degrees
 1013              		.loc 1 242 0
 1014 0624 103084E2 		add	r3, r4, #16
 1015 0628 0C0093E8 		ldmia	r3, {r2-r3}
 239:main.cpp      **** 						filter.y_angle=filter.y_rate*(filter.interval/1000.0);
 1016              		.loc 1 239 0
 1017 062c BC0084E5 		str	r0, [r4, #188]
 1018 0630 C01084E5 		str	r1, [r4, #192]
 242:main.cpp      **** 						filter.Axz = atan2(filter.RwEst[0], filter.RwEst[2])*180/PI;	//Get previous angle in degrees
 1019              		.loc 1 242 0
 1020 0634 030094E8 		ldmia	r4, {r0-r1}
 1021 0638 FEFFFFEB 		bl	atan2
 1022 063c 00289FE5 		ldr	r2, .L95+124
 1023 0640 0030A0E3 		mov	r3, #0
 1024 0644 FEFFFFEB 		bl	__muldf3
 1025 0648 F8279FE5 		ldr	r2, .L95+128
 1026 064c F8379FE5 		ldr	r3, .L95+132
 1027 0650 FEFFFFEB 		bl	__divdf3
 243:main.cpp      **** 						filter.Axz += filter.x_angle;	//Add the current angle to the previous one to get current angl
 1028              		.loc 1 243 0
 1029 0654 AC3084E2 		add	r3, r4, #172
 1030 0658 0C0093E8 		ldmia	r3, {r2-r3}
 1031 065c FEFFFFEB 		bl	__adddf3
 244:main.cpp      **** 						filter.Ayz = atan2(filter.RwEst[1], filter.RwEst[2])*180/PI;
 1032              		.loc 1 244 0
 1033 0660 103084E2 		add	r3, r4, #16
 1034 0664 0C0093E8 		ldmia	r3, {r2-r3}
 243:main.cpp      **** 						filter.Axz += filter.x_angle;	//Add the current angle to the previous one to get current angl
 1035              		.loc 1 243 0
 1036 0668 600084E5 		str	r0, [r4, #96]
 1037 066c 641084E5 		str	r1, [r4, #100]
 244:main.cpp      **** 						filter.Ayz = atan2(filter.RwEst[1], filter.RwEst[2])*180/PI;
 1038              		.loc 1 244 0
 1039 0670 081084E2 		add	r1, r4, #8
 1040 0674 030091E8 		ldmia	r1, {r0-r1}
 1041 0678 FEFFFFEB 		bl	atan2
 1042 067c C0279FE5 		ldr	r2, .L95+124
 1043 0680 0030A0E3 		mov	r3, #0
 1044 0684 FEFFFFEB 		bl	__muldf3
 1045 0688 B8279FE5 		ldr	r2, .L95+128
 1046 068c B8379FE5 		ldr	r3, .L95+132
 1047 0690 FEFFFFEB 		bl	__divdf3
 245:main.cpp      **** 						filter.Ayz += filter.y_angle;
 1048              		.loc 1 245 0
 1049 0694 BC3084E2 		add	r3, r4, #188
 1050 0698 0C0093E8 		ldmia	r3, {r2-r3}
 1051 069c FEFFFFEB 		bl	__adddf3
 1052 06a0 680084E5 		str	r0, [r4, #104]
 1053 06a4 6C1084E5 		str	r1, [r4, #108]
 1054              	.L52:
 1055              	.LBE21:
 248:main.cpp      **** 					if(filter.RwAcc[2] >=0)filter.signRzGyro=1;
 1056              		.loc 1 248 0
 1057 06a8 281084E2 		add	r1, r4, #40
 1058 06ac 030091E8 		ldmia	r1, {r0-r1}
 1059 06b0 0020A0E3 		mov	r2, #0
 1060 06b4 0030A0E3 		mov	r3, #0
 1061 06b8 FEFFFFEB 		bl	__gedf2
 249:main.cpp      **** 					else filter.signRzGyro=-1;
 1062              		.loc 1 249 0
 1063 06bc 000050E3 		cmp	r0, #0
 1064 06c0 0100A0A3 		movge	r0, #1
 1065 06c4 FF00A0B3 		movlt	r0, #255
 252:main.cpp      **** 					filter.RwGyro[0] = sin(filter.Axz * (PI/180));
 1066              		.loc 1 252 0
 1067 06c8 80279FE5 		ldr	r2, .L95+136
 1068 06cc 80379FE5 		ldr	r3, .L95+140
 248:main.cpp      **** 					if(filter.RwAcc[2] >=0)filter.signRzGyro=1;
 1069              		.loc 1 248 0
 1070 06d0 8800C4E5 		strb	r0, [r4, #136]
 252:main.cpp      **** 					filter.RwGyro[0] = sin(filter.Axz * (PI/180));
 1071              		.loc 1 252 0
 1072 06d4 601084E2 		add	r1, r4, #96
 1073 06d8 030091E8 		ldmia	r1, {r0-r1}
 1074 06dc FEFFFFEB 		bl	__muldf3
 1075 06e0 0060A0E1 		mov	r6, r0
 1076 06e4 0170A0E1 		mov	r7, r1
 1077 06e8 FEFFFFEB 		bl	sin
 1078 06ec 0080A0E1 		mov	r8, r0
 1079 06f0 0190A0E1 		mov	r9, r1
 1080 06f4 308084E5 		str	r8, [r4, #48]
 1081 06f8 349084E5 		str	r9, [r4, #52]
 253:main.cpp      **** 					filter.RwGyro[0] /= sqrt(1+cos(filter.Axz * (PI/180))*cos(filter.Axz * (PI/180))
 1082              		.loc 1 253 0
 1083 06fc 0600A0E1 		mov	r0, r6
 1084 0700 0710A0E1 		mov	r1, r7
 1085 0704 FEFFFFEB 		bl	cos
 254:main.cpp      **** 											*tan(filter.Ayz*(PI/180))*tan(filter.Ayz*(PI/180)));
 1086              		.loc 1 254 0
 1087 0708 40279FE5 		ldr	r2, .L95+136
 253:main.cpp      **** 					filter.RwGyro[0] /= sqrt(1+cos(filter.Axz * (PI/180))*cos(filter.Axz * (PI/180))
 1088              		.loc 1 253 0
 1089 070c 00A0A0E1 		mov	sl, r0
 1090 0710 01B0A0E1 		mov	fp, r1
 254:main.cpp      **** 											*tan(filter.Ayz*(PI/180))*tan(filter.Ayz*(PI/180)));
 1091              		.loc 1 254 0
 1092 0714 38379FE5 		ldr	r3, .L95+140
 1093 0718 681084E2 		add	r1, r4, #104
 1094 071c 030091E8 		ldmia	r1, {r0-r1}
 1095 0720 FEFFFFEB 		bl	__muldf3
 1096 0724 FEFFFFEB 		bl	tan
 1097 0728 0A20A0E1 		mov	r2, sl
 1098 072c 0060A0E1 		mov	r6, r0
 1099 0730 0170A0E1 		mov	r7, r1
 1100 0734 0B30A0E1 		mov	r3, fp
 1101 0738 0A00A0E1 		mov	r0, sl
 1102 073c 0B10A0E1 		mov	r1, fp
 1103 0740 FEFFFFEB 		bl	__muldf3
 1104 0744 0620A0E1 		mov	r2, r6
 1105 0748 0730A0E1 		mov	r3, r7
 1106 074c FEFFFFEB 		bl	__muldf3
 1107 0750 0620A0E1 		mov	r2, r6
 1108 0754 0730A0E1 		mov	r3, r7
 1109 0758 FEFFFFEB 		bl	__muldf3
 1110 075c F4269FE5 		ldr	r2, .L95+144
 1111 0760 0030A0E3 		mov	r3, #0
 1112 0764 FEFFFFEB 		bl	__adddf3
 1113 0768 FEFFFFEB 		bl	sqrt
 1114 076c 0020A0E1 		mov	r2, r0
 1115 0770 0130A0E1 		mov	r3, r1
 1116 0774 0800A0E1 		mov	r0, r8
 1117 0778 0910A0E1 		mov	r1, r9
 1118 077c FEFFFFEB 		bl	__divdf3
 256:main.cpp      **** 					filter.RwGyro[1] = sin(filter.Ayz * (PI/180));
 1119              		.loc 1 256 0
 1120 0780 C8269FE5 		ldr	r2, .L95+136
 1121 0784 C8369FE5 		ldr	r3, .L95+140
 254:main.cpp      **** 											*tan(filter.Ayz*(PI/180))*tan(filter.Ayz*(PI/180)));
 1122              		.loc 1 254 0
 1123 0788 300084E5 		str	r0, [r4, #48]
 1124 078c 341084E5 		str	r1, [r4, #52]
 256:main.cpp      **** 					filter.RwGyro[1] = sin(filter.Ayz * (PI/180));
 1125              		.loc 1 256 0
 1126 0790 681084E2 		add	r1, r4, #104
 1127 0794 030091E8 		ldmia	r1, {r0-r1}
 1128 0798 FEFFFFEB 		bl	__muldf3
 1129 079c 0060A0E1 		mov	r6, r0
 1130 07a0 0170A0E1 		mov	r7, r1
 1131 07a4 FEFFFFEB 		bl	sin
 1132 07a8 0080A0E1 		mov	r8, r0
 1133 07ac 0190A0E1 		mov	r9, r1
 1134 07b0 388084E5 		str	r8, [r4, #56]
 1135 07b4 3C9084E5 		str	r9, [r4, #60]
 257:main.cpp      **** 					filter.RwGyro[1] /= sqrt(1+cos(filter.Ayz * (PI/180))*cos(filter.Ayz * (PI/180))
 1136              		.loc 1 257 0
 1137 07b8 0600A0E1 		mov	r0, r6
 1138 07bc 0710A0E1 		mov	r1, r7
 1139 07c0 FEFFFFEB 		bl	cos
 258:main.cpp      **** 											*tan(filter.Axz*(PI/180))*tan(filter.Axz*(PI/180)));
 1140              		.loc 1 258 0
 1141 07c4 84269FE5 		ldr	r2, .L95+136
 257:main.cpp      **** 					filter.RwGyro[1] /= sqrt(1+cos(filter.Ayz * (PI/180))*cos(filter.Ayz * (PI/180))
 1142              		.loc 1 257 0
 1143 07c8 00A0A0E1 		mov	sl, r0
 1144 07cc 01B0A0E1 		mov	fp, r1
 258:main.cpp      **** 											*tan(filter.Axz*(PI/180))*tan(filter.Axz*(PI/180)));
 1145              		.loc 1 258 0
 1146 07d0 7C369FE5 		ldr	r3, .L95+140
 1147 07d4 601084E2 		add	r1, r4, #96
 1148 07d8 030091E8 		ldmia	r1, {r0-r1}
 1149 07dc FEFFFFEB 		bl	__muldf3
 1150 07e0 FEFFFFEB 		bl	tan
 1151 07e4 0A20A0E1 		mov	r2, sl
 1152 07e8 0060A0E1 		mov	r6, r0
 1153 07ec 0170A0E1 		mov	r7, r1
 1154 07f0 0B30A0E1 		mov	r3, fp
 1155 07f4 0A00A0E1 		mov	r0, sl
 1156 07f8 0B10A0E1 		mov	r1, fp
 1157 07fc FEFFFFEB 		bl	__muldf3
 1158 0800 0620A0E1 		mov	r2, r6
 1159 0804 0730A0E1 		mov	r3, r7
 1160 0808 FEFFFFEB 		bl	__muldf3
 1161 080c 0620A0E1 		mov	r2, r6
 1162 0810 0730A0E1 		mov	r3, r7
 1163 0814 FEFFFFEB 		bl	__muldf3
 1164 0818 38269FE5 		ldr	r2, .L95+144
 1165 081c 0030A0E3 		mov	r3, #0
 1166 0820 FEFFFFEB 		bl	__adddf3
 1167 0824 FEFFFFEB 		bl	sqrt
 1168 0828 0020A0E1 		mov	r2, r0
 1169 082c 0130A0E1 		mov	r3, r1
 1170 0830 0800A0E1 		mov	r0, r8
 1171 0834 0910A0E1 		mov	r1, r9
 1172 0838 FEFFFFEB 		bl	__divdf3
 1173 083c 0060A0E1 		mov	r6, r0
 1174 0840 0170A0E1 		mov	r7, r1
 1175 0844 386084E5 		str	r6, [r4, #56]
 1176 0848 3C7084E5 		str	r7, [r4, #60]
 260:main.cpp      **** 					filter.RwGyro[2] = filter.signRzGyro * sqrt(1-pow(filter.RwGyro[0],2)-pow(filter.RwGyro[1],2))
 1177              		.loc 1 260 0
 1178 084c 8800D4E5 		ldrb	r0, [r4, #136]	@ zero_extendqisi2
 1179 0850 FEFFFFEB 		bl	__floatsidf
 1180 0854 00A0A0E1 		mov	sl, r0
 1181 0858 01B0A0E1 		mov	fp, r1
 1182 085c 301084E2 		add	r1, r4, #48
 1183 0860 030091E8 		ldmia	r1, {r0-r1}
 1184 0864 0020A0E1 		mov	r2, r0
 1185 0868 0130A0E1 		mov	r3, r1
 1186 086c FEFFFFEB 		bl	__muldf3
 1187 0870 0620A0E1 		mov	r2, r6
 1188 0874 0730A0E1 		mov	r3, r7
 1189 0878 0080A0E1 		mov	r8, r0
 1190 087c 0190A0E1 		mov	r9, r1
 1191 0880 0600A0E1 		mov	r0, r6
 1192 0884 0710A0E1 		mov	r1, r7
 1193 0888 FEFFFFEB 		bl	__muldf3
 1194 088c 0820A0E1 		mov	r2, r8
 1195 0890 0060A0E1 		mov	r6, r0
 1196 0894 0170A0E1 		mov	r7, r1
 1197 0898 0930A0E1 		mov	r3, r9
 1198 089c B4059FE5 		ldr	r0, .L95+144
 1199 08a0 0010A0E3 		mov	r1, #0
 1200 08a4 FEFFFFEB 		bl	__subdf3
 1201 08a8 0620A0E1 		mov	r2, r6
 1202 08ac 0730A0E1 		mov	r3, r7
 1203 08b0 FEFFFFEB 		bl	__subdf3
 1204 08b4 FEFFFFEB 		bl	sqrt
 1205 08b8 0020A0E1 		mov	r2, r0
 1206 08bc 0130A0E1 		mov	r3, r1
 1207 08c0 0A00A0E1 		mov	r0, sl
 1208 08c4 0B10A0E1 		mov	r1, fp
 1209 08c8 FEFFFFEB 		bl	__muldf3
 1210 08cc 400084E5 		str	r0, [r4, #64]
 1211 08d0 441084E5 		str	r1, [r4, #68]
 1212              	.L49:
 1213              	.LVL34:
 1214              	.LBE20:
 1215              	.LBE16:
 1216              	.LBB23:
 266:main.cpp      **** 					filter.RwEst[w] = (filter.RwAcc[w] + filter.RwGyro[w] * filter.gyro_weight)/(1+filter.gyro_wei
 1217              		.loc 1 266 0 discriminator 1
 1218 08d4 807084E2 		add	r7, r4, #128
 1219 08d8 C00097E8 		ldmia	r7, {r6-r7}
 1220 08dc 74259FE5 		ldr	r2, .L95+144
 1221 08e0 0600A0E1 		mov	r0, r6
 1222 08e4 0710A0E1 		mov	r1, r7
 1223 08e8 0030A0E3 		mov	r3, #0
 1224 08ec FEFFFFEB 		bl	__adddf3
 1225 08f0 64559FE5 		ldr	r5, .L95+148
 1226 08f4 00A0A0E1 		mov	sl, r0
 1227 08f8 01B0A0E1 		mov	fp, r1
 1228              	.LVL35:
 1229              	.L55:
 266:main.cpp      **** 					filter.RwEst[w] = (filter.RwAcc[w] + filter.RwGyro[w] * filter.gyro_weight)/(1+filter.gyro_wei
 1230              		.loc 1 266 0 is_stmt 0 discriminator 2
 1231 08fc 0003B5E8 		ldmia	r5!, {r8-r9}
 1232 0900 0600A0E1 		mov	r0, r6
 1233 0904 103085E2 		add	r3, r5, #16
 1234 0908 0C0093E8 		ldmia	r3, {r2-r3}
 1235 090c 0710A0E1 		mov	r1, r7
 1236 0910 FEFFFFEB 		bl	__muldf3
 1237 0914 0020A0E1 		mov	r2, r0
 1238 0918 0130A0E1 		mov	r3, r1
 1239 091c 0800A0E1 		mov	r0, r8
 1240 0920 0910A0E1 		mov	r1, r9
 1241 0924 FEFFFFEB 		bl	__adddf3
 1242 0928 0A20A0E1 		mov	r2, sl
 1243 092c 0B30A0E1 		mov	r3, fp
 1244 0930 FEFFFFEB 		bl	__divdf3
 1245 0934 200005E5 		str	r0, [r5, #-32]
 1246 0938 1C1005E5 		str	r1, [r5, #-28]
 264:main.cpp      **** 				for(int w=0; w<3; w++)
 1247              		.loc 1 264 0 is_stmt 1 discriminator 2
 1248 093c 1C159FE5 		ldr	r1, .L95+152
 1249 0940 010055E1 		cmp	r5, r1
 1250 0944 ECFFFF1A 		bne	.L55
 1251              	.LBE23:
 268:main.cpp      **** 				filter.normalizeVector(filter.RwEst);
 1252              		.loc 1 268 0
 1253 0948 300041E2 		sub	r0, r1, #48
 1254 094c 0010A0E1 		mov	r1, r0
 1255 0950 FEFFFFEB 		bl	_ZN7cSensor15normalizeVectorEPd
 271:main.cpp      **** 				filter.EstAxz=atan2(filter.RwEst[0], filter.RwEst[2])*180/PI;
 1256              		.loc 1 271 0
 1257 0954 103084E2 		add	r3, r4, #16
 1258 0958 0C0093E8 		ldmia	r3, {r2-r3}
 1259 095c 030094E8 		ldmia	r4, {r0-r1}
 1260 0960 FEFFFFEB 		bl	atan2
 1261 0964 D8249FE5 		ldr	r2, .L95+124
 1262 0968 0030A0E3 		mov	r3, #0
 1263 096c FEFFFFEB 		bl	__muldf3
 1264 0970 D0249FE5 		ldr	r2, .L95+128
 1265 0974 D0349FE5 		ldr	r3, .L95+132
 1266 0978 FEFFFFEB 		bl	__divdf3
 272:main.cpp      **** 				filter.EstAyz=atan2(filter.RwEst[1], filter.RwEst[2])*180/PI;
 1267              		.loc 1 272 0
 1268 097c 103084E2 		add	r3, r4, #16
 1269 0980 0C0093E8 		ldmia	r3, {r2-r3}
 271:main.cpp      **** 				filter.EstAxz=atan2(filter.RwEst[0], filter.RwEst[2])*180/PI;
 1270              		.loc 1 271 0
 1271 0984 700084E5 		str	r0, [r4, #112]
 1272 0988 741084E5 		str	r1, [r4, #116]
 272:main.cpp      **** 				filter.EstAyz=atan2(filter.RwEst[1], filter.RwEst[2])*180/PI;
 1273              		.loc 1 272 0
 1274 098c 081084E2 		add	r1, r4, #8
 1275 0990 030091E8 		ldmia	r1, {r0-r1}
 1276 0994 FEFFFFEB 		bl	atan2
 1277 0998 A4249FE5 		ldr	r2, .L95+124
 1278 099c 0030A0E3 		mov	r3, #0
 1279 09a0 FEFFFFEB 		bl	__muldf3
 1280 09a4 9C249FE5 		ldr	r2, .L95+128
 1281 09a8 9C349FE5 		ldr	r3, .L95+132
 1282 09ac FEFFFFEB 		bl	__divdf3
 1283 09b0 780084E5 		str	r0, [r4, #120]
 1284 09b4 7C1084E5 		str	r1, [r4, #124]
 275:main.cpp      **** 				filter.RwMag[0] = compass.getX();
 1285              		.loc 1 275 0
 1286 09b8 4C049FE5 		ldr	r0, .L95+68
 1287 09bc FEFFFFEB 		bl	_ZN8cHMC58434getXEv
 1288 09c0 FEFFFFEB 		bl	__extendsfdf2
 1289 09c4 480084E5 		str	r0, [r4, #72]
 1290 09c8 4C1084E5 		str	r1, [r4, #76]
 276:main.cpp      **** 				filter.RwMag[1] = compass.getY();
 1291              		.loc 1 276 0
 1292 09cc 38049FE5 		ldr	r0, .L95+68
 1293 09d0 FEFFFFEB 		bl	_ZN8cHMC58434getYEv
 1294 09d4 FEFFFFEB 		bl	__extendsfdf2
 1295 09d8 500084E5 		str	r0, [r4, #80]
 1296 09dc 541084E5 		str	r1, [r4, #84]
 277:main.cpp      **** 				filter.RwMag[2] = compass.getZ();
 1297              		.loc 1 277 0
 1298 09e0 24049FE5 		ldr	r0, .L95+68
 1299 09e4 FEFFFFEB 		bl	_ZN8cHMC58434getZEv
 1300 09e8 FEFFFFEB 		bl	__extendsfdf2
 1301 09ec 00A0A0E1 		mov	sl, r0
 1302 09f0 01B0A0E1 		mov	fp, r1
 280:main.cpp      **** 				filter.x_h = filter.RwMag[0]*cos(filter.EstAyz*(PI/180))+
 1303              		.loc 1 280 0
 1304 09f4 54249FE5 		ldr	r2, .L95+136
 1305 09f8 54349FE5 		ldr	r3, .L95+140
 277:main.cpp      **** 				filter.RwMag[2] = compass.getZ();
 1306              		.loc 1 277 0
 1307 09fc 58A084E5 		str	sl, [r4, #88]
 1308 0a00 5CB084E5 		str	fp, [r4, #92]
 280:main.cpp      **** 				filter.x_h = filter.RwMag[0]*cos(filter.EstAyz*(PI/180))+
 1309              		.loc 1 280 0
 1310 0a04 781084E2 		add	r1, r4, #120
 1311 0a08 030091E8 		ldmia	r1, {r0-r1}
 1312 0a0c FEFFFFEB 		bl	__muldf3
 1313 0a10 0060A0E1 		mov	r6, r0
 1314 0a14 0170A0E1 		mov	r7, r1
 1315 0a18 FEFFFFEB 		bl	cos
 281:main.cpp      **** 					filter.RwMag[1]*sin(filter.EstAxz*(PI/180))*sin(filter.EstAyz*(PI/180))-
 1316              		.loc 1 281 0
 1317 0a1c 503084E2 		add	r3, r4, #80
 1318 0a20 0C0093E8 		ldmia	r3, {r2-r3}
 280:main.cpp      **** 				filter.x_h = filter.RwMag[0]*cos(filter.EstAyz*(PI/180))+
 1319              		.loc 1 280 0
 1320 0a24 60008DE5 		str	r0, [sp, #96]
 1321 0a28 64108DE5 		str	r1, [sp, #100]
 281:main.cpp      **** 					filter.RwMag[1]*sin(filter.EstAxz*(PI/180))*sin(filter.EstAyz*(PI/180))-
 1322              		.loc 1 281 0
 1323 0a2c 48208DE5 		str	r2, [sp, #72]
 1324 0a30 4C308DE5 		str	r3, [sp, #76]
 1325 0a34 701084E2 		add	r1, r4, #112
 1326 0a38 030091E8 		ldmia	r1, {r0-r1}
 1327 0a3c 0C249FE5 		ldr	r2, .L95+136
 1328 0a40 0C349FE5 		ldr	r3, .L95+140
 1329 0a44 FEFFFFEB 		bl	__muldf3
 1330 0a48 0080A0E1 		mov	r8, r0
 1331 0a4c 0190A0E1 		mov	r9, r1
 1332 0a50 FEFFFFEB 		bl	sin
 1333 0a54 50008DE5 		str	r0, [sp, #80]
 1334 0a58 54108DE5 		str	r1, [sp, #84]
 1335 0a5c 0600A0E1 		mov	r0, r6
 1336 0a60 0710A0E1 		mov	r1, r7
 1337 0a64 FEFFFFEB 		bl	sin
 1338 0a68 0060A0E1 		mov	r6, r0
 1339 0a6c 0170A0E1 		mov	r7, r1
 282:main.cpp      **** 					filter.RwMag[2]*cos(filter.EstAxz*(PI/180))*sin(filter.EstAyz*(PI/180));
 1340              		.loc 1 282 0
 1341 0a70 0800A0E1 		mov	r0, r8
 1342 0a74 0910A0E1 		mov	r1, r9
 1343 0a78 FEFFFFEB 		bl	cos
 1344 0a7c 483084E2 		add	r3, r4, #72
 1345 0a80 0C0093E8 		ldmia	r3, {r2-r3}
 1346 0a84 58008DE5 		str	r0, [sp, #88]
 1347 0a88 5C108DE5 		str	r1, [sp, #92]
 1348 0a8c 60108DE2 		add	r1, sp, #96
 1349 0a90 030091E8 		ldmia	r1, {r0-r1}
 1350 0a94 FEFFFFEB 		bl	__muldf3
 1351 0a98 50308DE2 		add	r3, sp, #80
 1352 0a9c 0C0093E8 		ldmia	r3, {r2-r3}
 1353 0aa0 0080A0E1 		mov	r8, r0
 1354 0aa4 0190A0E1 		mov	r9, r1
 1355 0aa8 48108DE2 		add	r1, sp, #72
 1356 0aac 030091E8 		ldmia	r1, {r0-r1}
 1357 0ab0 FEFFFFEB 		bl	__muldf3
 1358 0ab4 0620A0E1 		mov	r2, r6
 1359 0ab8 0730A0E1 		mov	r3, r7
 1360 0abc FEFFFFEB 		bl	__muldf3
 1361 0ac0 0020A0E1 		mov	r2, r0
 1362 0ac4 0130A0E1 		mov	r3, r1
 1363 0ac8 0800A0E1 		mov	r0, r8
 1364 0acc 0910A0E1 		mov	r1, r9
 1365 0ad0 FEFFFFEB 		bl	__adddf3
 1366 0ad4 58308DE2 		add	r3, sp, #88
 1367 0ad8 0C0093E8 		ldmia	r3, {r2-r3}
 1368 0adc 0080A0E1 		mov	r8, r0
 1369 0ae0 0190A0E1 		mov	r9, r1
 1370 0ae4 0A00A0E1 		mov	r0, sl
 1371 0ae8 0B10A0E1 		mov	r1, fp
 1372 0aec FEFFFFEB 		bl	__muldf3
 1373 0af0 0620A0E1 		mov	r2, r6
 1374 0af4 0730A0E1 		mov	r3, r7
 1375 0af8 FEFFFFEB 		bl	__muldf3
 1376 0afc 0020A0E1 		mov	r2, r0
 1377 0b00 0130A0E1 		mov	r3, r1
 1378 0b04 0800A0E1 		mov	r0, r8
 1379 0b08 0910A0E1 		mov	r1, r9
 1380 0b0c FEFFFFEB 		bl	__subdf3
 1381 0b10 0080A0E1 		mov	r8, r0
 1382 0b14 0190A0E1 		mov	r9, r1
 284:main.cpp      **** 				filter.y_h=filter.RwMag[1]*cos(filter.EstAxz*(PI/180))+filter.RwMag[2]*sin(filter.EstAxz*(PI/18
 1383              		.loc 1 284 0
 1384 0b18 58308DE2 		add	r3, sp, #88
 1385 0b1c 0C0093E8 		ldmia	r3, {r2-r3}
 282:main.cpp      **** 					filter.RwMag[2]*cos(filter.EstAxz*(PI/180))*sin(filter.EstAyz*(PI/180));
 1386              		.loc 1 282 0
 1387 0b20 CC8084E5 		str	r8, [r4, #204]
 1388 0b24 D09084E5 		str	r9, [r4, #208]
 284:main.cpp      **** 				filter.y_h=filter.RwMag[1]*cos(filter.EstAxz*(PI/180))+filter.RwMag[2]*sin(filter.EstAxz*(PI/18
 1389              		.loc 1 284 0
 1390 0b28 48108DE2 		add	r1, sp, #72
 1391 0b2c 030091E8 		ldmia	r1, {r0-r1}
 1392 0b30 FEFFFFEB 		bl	__muldf3
 1393 0b34 50308DE2 		add	r3, sp, #80
 1394 0b38 0C0093E8 		ldmia	r3, {r2-r3}
 1395 0b3c 0060A0E1 		mov	r6, r0
 1396 0b40 0170A0E1 		mov	r7, r1
 1397 0b44 0A00A0E1 		mov	r0, sl
 1398 0b48 0B10A0E1 		mov	r1, fp
 1399 0b4c FEFFFFEB 		bl	__muldf3
 1400 0b50 0020A0E1 		mov	r2, r0
 1401 0b54 0130A0E1 		mov	r3, r1
 1402 0b58 0600A0E1 		mov	r0, r6
 1403 0b5c 0710A0E1 		mov	r1, r7
 1404 0b60 FEFFFFEB 		bl	__adddf3
 1405 0b64 0060A0E1 		mov	r6, r0
 1406 0b68 0170A0E1 		mov	r7, r1
 1407 0b6c D46084E5 		str	r6, [r4, #212]
 1408 0b70 D87084E5 		str	r7, [r4, #216]
 287:main.cpp      **** 				if(filter.x_h < 0)filter.heading = 180 - atan2(filter.y_h, filter.x_h)*180/PI;
 1409              		.loc 1 287 0
 1410 0b74 0800A0E1 		mov	r0, r8
 1411 0b78 0910A0E1 		mov	r1, r9
 1412 0b7c 0020A0E3 		mov	r2, #0
 1413 0b80 0030A0E3 		mov	r3, #0
 1414 0b84 FEFFFFEB 		bl	__ltdf2
 1415 0b88 000050E3 		cmp	r0, #0
 1416 0b8c 0E0000AA 		bge	.L89
 287:main.cpp      **** 				if(filter.x_h < 0)filter.heading = 180 - atan2(filter.y_h, filter.x_h)*180/PI;
 1417              		.loc 1 287 0 is_stmt 0 discriminator 1
 1418 0b90 0820A0E1 		mov	r2, r8
 1419 0b94 0930A0E1 		mov	r3, r9
 1420 0b98 0600A0E1 		mov	r0, r6
 1421 0b9c 0710A0E1 		mov	r1, r7
 1422 0ba0 FEFFFFEB 		bl	atan2
 1423 0ba4 98229FE5 		ldr	r2, .L95+124
 1424 0ba8 0030A0E3 		mov	r3, #0
 1425 0bac FEFFFFEB 		bl	__muldf3
 1426 0bb0 90229FE5 		ldr	r2, .L95+128
 1427 0bb4 90329FE5 		ldr	r3, .L95+132
 1428 0bb8 FEFFFFEB 		bl	__divdf3
 1429 0bbc 0020A0E1 		mov	r2, r0
 1430 0bc0 0130A0E1 		mov	r3, r1
 1431 0bc4 78029FE5 		ldr	r0, .L95+124
 1432 0bc8 300000EA 		b	.L94
 1433              	.L89:
 288:main.cpp      **** 				else if((filter.x_h > 0) && (filter.y_h < 0))filter.heading = -atan2(filter.y_h, filter.x_h)*18
 1434              		.loc 1 288 0 is_stmt 1
 1435 0bcc 0800A0E1 		mov	r0, r8
 1436 0bd0 0910A0E1 		mov	r1, r9
 1437 0bd4 0020A0E3 		mov	r2, #0
 1438 0bd8 0030A0E3 		mov	r3, #0
 1439 0bdc FEFFFFEB 		bl	__gtdf2
 1440 0be0 000050E3 		cmp	r0, #0
 1441 0be4 2C0000DA 		ble	.L59
 288:main.cpp      **** 				else if((filter.x_h > 0) && (filter.y_h < 0))filter.heading = -atan2(filter.y_h, filter.x_h)*18
 1442              		.loc 1 288 0 is_stmt 0 discriminator 1
 1443 0be8 0710A0E1 		mov	r1, r7
 1444 0bec 0600A0E1 		mov	r0, r6
 1445 0bf0 0020A0E3 		mov	r2, #0
 1446 0bf4 0030A0E3 		mov	r3, #0
 1447 0bf8 FEFFFFEB 		bl	__ltdf2
 1448 0bfc 000050E3 		cmp	r0, #0
 1449 0c00 0710A0E1 		mov	r1, r7
 1450 0c04 0600A0E1 		mov	r0, r6
 1451 0c08 0D0000AA 		bge	.L90
 288:main.cpp      **** 				else if((filter.x_h > 0) && (filter.y_h < 0))filter.heading = -atan2(filter.y_h, filter.x_h)*18
 1452              		.loc 1 288 0 discriminator 2
 1453 0c0c 0820A0E1 		mov	r2, r8
 1454 0c10 0930A0E1 		mov	r3, r9
 1455 0c14 FEFFFFEB 		bl	atan2
 1456 0c18 022180E2 		add	r2, r0, #-2147483648
 1457 0c1c 0200A0E1 		mov	r0, r2
 1458 0c20 0030A0E3 		mov	r3, #0
 1459 0c24 18229FE5 		ldr	r2, .L95+124
 1460 0c28 FEFFFFEB 		bl	__muldf3
 1461 0c2c 14229FE5 		ldr	r2, .L95+128
 1462 0c30 14329FE5 		ldr	r3, .L95+132
 1463 0c34 FEFFFFEB 		bl	__divdf3
 1464              	.L93:
 1465 0c38 DC0084E5 		str	r0, [r4, #220]
 1466 0c3c E01084E5 		str	r1, [r4, #224]
 1467 0c40 2F0000EA 		b	.L58
 1468              	.L90:
 289:main.cpp      **** 				else if((filter.x_h > 0) && (filter.y_h > 0))filter.heading = 360 - atan2(filter.y_h, filter.x_
 1469              		.loc 1 289 0 is_stmt 1 discriminator 1
 1470 0c44 0020A0E3 		mov	r2, #0
 1471 0c48 0030A0E3 		mov	r3, #0
 1472 0c4c FEFFFFEB 		bl	__gtdf2
 1473 0c50 000050E3 		cmp	r0, #0
 1474 0c54 100000DA 		ble	.L59
 289:main.cpp      **** 				else if((filter.x_h > 0) && (filter.y_h > 0))filter.heading = 360 - atan2(filter.y_h, filter.x_
 1475              		.loc 1 289 0 is_stmt 0 discriminator 2
 1476 0c58 0820A0E1 		mov	r2, r8
 1477 0c5c 0930A0E1 		mov	r3, r9
 1478 0c60 0600A0E1 		mov	r0, r6
 1479 0c64 0710A0E1 		mov	r1, r7
 1480 0c68 FEFFFFEB 		bl	atan2
 1481 0c6c D0219FE5 		ldr	r2, .L95+124
 1482 0c70 0030A0E3 		mov	r3, #0
 1483 0c74 FEFFFFEB 		bl	__muldf3
 1484 0c78 C8219FE5 		ldr	r2, .L95+128
 1485 0c7c C8319FE5 		ldr	r3, .L95+132
 1486 0c80 FEFFFFEB 		bl	__divdf3
 1487 0c84 0020A0E1 		mov	r2, r0
 1488 0c88 D4019FE5 		ldr	r0, .L95+156
 1489 0c8c 0130A0E1 		mov	r3, r1
 1490              	.L94:
 1491 0c90 0010A0E3 		mov	r1, #0
 1492 0c94 FEFFFFEB 		bl	__subdf3
 1493 0c98 E6FFFFEA 		b	.L93
 1494              	.L59:
 290:main.cpp      **** 				else if((filter.x_h == 0)&& (filter.y_h < 0))filter.heading = 90;
 1495              		.loc 1 290 0 is_stmt 1
 1496 0c9c 0800A0E1 		mov	r0, r8
 1497 0ca0 0910A0E1 		mov	r1, r9
 1498 0ca4 0020A0E3 		mov	r2, #0
 1499 0ca8 0030A0E3 		mov	r3, #0
 1500 0cac FEFFFFEB 		bl	__eqdf2
 1501 0cb0 000050E3 		cmp	r0, #0
 1502 0cb4 1200001A 		bne	.L58
 290:main.cpp      **** 				else if((filter.x_h == 0)&& (filter.y_h < 0))filter.heading = 90;
 1503              		.loc 1 290 0 is_stmt 0 discriminator 1
 1504 0cb8 0710A0E1 		mov	r1, r7
 1505 0cbc 0600A0E1 		mov	r0, r6
 1506 0cc0 0020A0E3 		mov	r2, #0
 1507 0cc4 0030A0E3 		mov	r3, #0
 1508 0cc8 FEFFFFEB 		bl	__ltdf2
 1509 0ccc 000050E3 		cmp	r0, #0
 1510 0cd0 90019FB5 		ldrlt	r0, .L95+160
 1511 0cd4 0010A0B3 		movlt	r1, #0
 1512 0cd8 D6FFFFBA 		blt	.L93
 291:main.cpp      **** 				else if((filter.x_h == 0)&& (filter.y_h > 0))filter.heading = 270;
 1513              		.loc 1 291 0 is_stmt 1 discriminator 1
 1514 0cdc 0600A0E1 		mov	r0, r6
 1515 0ce0 0710A0E1 		mov	r1, r7
 1516 0ce4 0020A0E3 		mov	r2, #0
 1517 0ce8 0030A0E3 		mov	r3, #0
 1518 0cec FEFFFFEB 		bl	__gtdf2
 1519 0cf0 000050E3 		cmp	r0, #0
 291:main.cpp      **** 				else if((filter.x_h == 0)&& (filter.y_h > 0))filter.heading = 270;
 1520              		.loc 1 291 0 is_stmt 0 discriminator 2
 1521 0cf4 70119FC5 		ldrgt	r1, .L95+164
 1522 0cf8 0020A0C3 		movgt	r2, #0
 1523 0cfc DC1084C5 		strgt	r1, [r4, #220]
 1524 0d00 E02084C5 		strgt	r2, [r4, #224]
 1525              	.L58:
 293:main.cpp      **** 				sprintf(sensor_string, "%06ld,%5.2f,%5.2f,%5.2f\n\r", millis(), filter.EstAxz, filter.EstAyz, f
 1526              		.loc 1 293 0 is_stmt 1
 1527 0d04 FEFFFFEB 		bl	millis
 1528 0d08 787084E2 		add	r7, r4, #120
 1529 0d0c C00097E8 		ldmia	r7, {r6-r7}
 1530 0d10 741094E5 		ldr	r1, [r4, #116]
 1531 0d14 703094E5 		ldr	r3, [r4, #112]
 1532 0d18 C0008DE9 		stmib	sp, {r6-r7}
 1533 0d1c DC7084E2 		add	r7, r4, #220
 1534 0d20 C00097E8 		ldmia	r7, {r6-r7}
 1535 0d24 0020A0E1 		mov	r2, r0
 1536 0d28 00108DE5 		str	r1, [sp, #0]
 1537 0d2c 00019FE5 		ldr	r0, .L95+108
 1538 0d30 38119FE5 		ldr	r1, .L95+168
 1539 0d34 0C608DE5 		str	r6, [sp, #12]
 1540 0d38 10708DE5 		str	r7, [sp, #16]
 1541 0d3c FEFFFFEB 		bl	sprintf
 1542              	.L47:
 1543              	.LBE24:
 1544              	.LBE27:
 296:main.cpp      **** 			if(configuration.log_sensor){
 1545              		.loc 1 296 0
 1546 0d40 8C309FE5 		ldr	r3, .L95+12
 1547 0d44 0030D3E5 		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 1548 0d48 000053E3 		cmp	r3, #0
 1549 0d4c 0C00000A 		beq	.L70
 299:main.cpp      **** 				strcat(sensor_log_string, sensor_string);
 1550              		.loc 1 299 0
 1551 0d50 CC009FE5 		ldr	r0, .L95+92
 1552 0d54 FF1080E2 		add	r1, r0, #255
 1553 0d58 FEFFFFEB 		bl	strcat
 300:main.cpp      **** 				if(strlen(sensor_log_string) > 195)
 1554              		.loc 1 300 0
 1555 0d5c C0009FE5 		ldr	r0, .L95+92
 1556 0d60 FEFFFFEB 		bl	strlen
 1557 0d64 C30050E3 		cmp	r0, #195
 1558 0d68 0500009A 		bls	.L70
 302:main.cpp      **** 					sensorData.save(sensor_log_string);
 1559              		.loc 1 302 0
 1560 0d6c 74009FE5 		ldr	r0, .L95+32
 1561 0d70 491080E2 		add	r1, r0, #73
 1562 0d74 FEFFFFEB 		bl	_ZN7cMemory4saveEPc
 303:main.cpp      **** 					strcpy(sensor_log_string, "");
 1563              		.loc 1 303 0
 1564 0d78 A4009FE5 		ldr	r0, .L95+92
 1565 0d7c A4109FE5 		ldr	r1, .L95+96
 1566 0d80 FEFFFFEB 		bl	strcpy
 1567              	.L70:
 307:main.cpp      **** 			if(configuration.output_messages == 1 || configuration.output_messages ==3){
 1568              		.loc 1 307 0
 1569 0d84 48309FE5 		ldr	r3, .L95+12
 1570 0d88 0C30D3E5 		ldrb	r3, [r3, #12]	@ zero_extendqisi2
 1571 0d8c 010053E3 		cmp	r3, #1
 1572 0d90 03005313 		cmpne	r3, #3
 308:main.cpp      **** 				rprintf("%s", sensor_string);
 1573              		.loc 1 308 0
 1574 0d94 D8009F05 		ldreq	r0, .L95+172
 1575 0d98 94109F05 		ldreq	r1, .L95+108
 1576 0d9c FEFFFF0B 		bleq	rprintf
 1577              	.L45:
 1578              	.LBE28:
 1579              	.LBE29:
 314:main.cpp      **** 		if(IOPIN0 & (1<<23))
 1580              		.loc 1 314 0
 1581 0da0 24309FE5 		ldr	r3, .L95+4
 1582 0da4 003093E5 		ldr	r3, [r3, #0]
 1583 0da8 020513E3 		tst	r3, #8388608
 1584 0dac EFFCFF0A 		beq	.L87
 316:main.cpp      **** 			VICIntEnClr = INT_TIMER0 |INT_UART1;	//Stop all running interrupts			
 1585              		.loc 1 316 0
 1586 0db0 9020A0E3 		mov	r2, #144
 1587 0db4 0030E0E3 		mvn	r3, #0
 1588 0db8 EB2F03E5 		str	r2, [r3, #-4075]
 317:main.cpp      **** 			main_msc();								//Open the mass storage device
 1589              		.loc 1 317 0
 1590 0dbc FEFFFFEB 		bl	main_msc
 318:main.cpp      **** 			reset();								//Reset to check for new FW
 1591              		.loc 1 318 0
 1592 0dc0 FEFFFFEB 		bl	_Z5resetv
 1593 0dc4 E9FCFFEA 		b	.L87
 1594              	.L96:
 1595              		.align	2
 1596              	.L95:
 1597 0dc8 5B000000 		.word	.LC6
 1598 0dcc 008002E0 		.word	-536707072
 1599 0dd0 40420F00 		.word	1000000
 1600 0dd4 00000000 		.word	configuration
 1601 0dd8 52000000 		.word	.LC5
 1602 0ddc 79000000 		.word	.LC7
 1603 0de0 84000000 		.word	.LC8
 1604 0de4 00000000 		.word	.LANCHOR0
 1605 0de8 24000000 		.word	.LANCHOR0+36
 1606 0dec 96000000 		.word	.LC9
 1607 0df0 9D000000 		.word	.LC10
 1608 0df4 48000000 		.word	.LANCHOR0+72
 1609 0df8 A2000000 		.word	.LC11
 1610 0dfc 00000000 		.word	filter
 1611 0e00 00000000 		.word	timer0IntFlag
 1612 0e04 00000000 		.word	accelerometer
 1613 0e08 00000000 		.word	gyro
 1614 0e0c 00000000 		.word	compass
 1615 0e10 00000000 		.word	uart1MessageComplete
 1616 0e14 00000000 		.word	uart1Message
 1617 0e18 2C000000 		.word	gps+44
 1618 0e1c A7000000 		.word	.LC12
 1619 0e20 00000000 		.word	uart0MessageComplete
 1620 0e24 6D000000 		.word	.LANCHOR0+109
 1621 0e28 AB000000 		.word	.LC13
 1622 0e2c 10000000 		.word	.LANCHOR0+16
 1623 0e30 AC000000 		.word	.LC14
 1624 0e34 6C010000 		.word	.LANCHOR0+364
 1625 0e38 9999B93F 		.word	1069128089
 1626 0e3c 9A999999 		.word	-1717986918
 1627 0e40 00408F40 		.word	1083129856
 1628 0e44 00806640 		.word	1080459264
 1629 0e48 CA210940 		.word	1074340298
 1630 0e4c 6F1283C0 		.word	-1065151889
 1631 0e50 24DF913F 		.word	1066524452
 1632 0e54 05A11E17 		.word	387883269
 1633 0e58 0000F03F 		.word	1072693248
 1634 0e5c 18000000 		.word	filter+24
 1635 0e60 30000000 		.word	filter+48
 1636 0e64 00807640 		.word	1081507840
 1637 0e68 00805640 		.word	1079410688
 1638 0e6c 00E07040 		.word	1081139200
 1639 0e70 EA000000 		.word	.LC15
 1640 0e74 04010000 		.word	.LC16
 1641              	.LBE11:
 1642              	.LBE10:
 1643              		.cfi_endproc
 1644              	.LFE0:
 1646              		.align	2
 1648              	_GLOBAL__sub_I_major_version:
 1649              	.LFB6:
 1650              		.loc 1 458 0
 1651              		.cfi_startproc
 1652              		@ Function supports interworking.
 1653              		@ args = 0, pretend = 0, frame = 0
 1654              		@ frame_needed = 0, uses_anonymous_args = 0
 1655              	.LVL36:
 1656 0e78 10402DE9 		stmfd	sp!, {r4, lr}
 1657              	.LCFI5:
 1658              		.cfi_def_cfa_offset 8
 1659              		.cfi_offset 14, -4
 1660              		.cfi_offset 4, -8
 1661              	.LBB30:
 1662              	.LBB31:
  69:main.cpp      **** cMemory sensorData;
 1663              		.loc 1 69 0
 1664 0e7c 1C409FE5 		ldr	r4, .L98
 1665 0e80 240084E2 		add	r0, r4, #36
 1666 0e84 FEFFFFEB 		bl	_ZN7cMemoryC1Ev
  70:main.cpp      **** cMemory gpsData;
 1667              		.loc 1 70 0
 1668 0e88 480084E2 		add	r0, r4, #72
 1669 0e8c FEFFFFEB 		bl	_ZN7cMemoryC1Ev
  71:main.cpp      **** cMemory configData;
 1670              		.loc 1 71 0
 1671 0e90 0400A0E1 		mov	r0, r4
 1672 0e94 FEFFFFEB 		bl	_ZN7cMemoryC1Ev
 1673              	.LBE31:
 1674              	.LBE30:
 1675              		.loc 1 458 0
 1676 0e98 1040BDE8 		ldmfd	sp!, {r4, lr}
 1677 0e9c 1EFF2FE1 		bx	lr
 1678              	.L99:
 1679              		.align	2
 1680              	.L98:
 1681 0ea0 00000000 		.word	.LANCHOR0
 1682              		.cfi_endproc
 1683              	.LFE6:
 1685              		.section	.ctors,"aw",%progbits
 1686              		.align	2
 1687 0000 00000000 		.word	_GLOBAL__sub_I_major_version
 1688              		.global	configData
 1689              		.global	gpsData
 1690              		.global	sensorData
 1691              		.global	sensor_log_string
 1692              		.global	sensor_string
 1693              		.global	sensors_updated
 1694              		.global	minor_version
 1695              		.global	major_version
 1696              		.section	.rodata.str1.1,"aMS",%progbits,1
 1697              	.LC0:
 1698 0000 47505320 		.ascii	"GPS Failed.\000"
 1698      4661696C 
 1698      65642E00 
 1699              	.LC1:
 1700 000c 41636365 		.ascii	"Accel Failed to ping\000"
 1700      6C204661 
 1700      696C6564 
 1700      20746F20 
 1700      70696E67 
 1701              	.LC2:
 1702 0021 4779726F 		.ascii	"Gyro failed to ping\000"
 1702      20666169 
 1702      6C656420 
 1702      746F2070 
 1702      696E6700 
 1703              	.LC3:
 1704 0035 436F6D70 		.ascii	"Compass failed to ping\000"
 1704      61737320 
 1704      6661696C 
 1704      65642074 
 1704      6F207069 
 1705              	.LC4:
 1706 004c 50617373 		.ascii	"Pass!\000"
 1706      2100
 1707              	.LC5:
 1708 0052 54657374 		.ascii	"Test.txt\000"
 1708      2E747874 
 1708      00
 1709              	.LC6:
 1710 005b 53442043 		.ascii	"SD Card Initialization Failed\000"
 1710      61726420 
 1710      496E6974 
 1710      69616C69 
 1710      7A617469 
 1711              	.LC7:
 1712 0079 54657374 		.ascii	"Testing...\000"
 1712      696E672E 
 1712      2E2E00
 1713              	.LC8:
 1714 0084 636F6E66 		.ascii	"configuration.txt\000"
 1714      69677572 
 1714      6174696F 
 1714      6E2E7478 
 1714      7400
 1715              	.LC9:
 1716 0096 53656E73 		.ascii	"Sensor\000"
 1716      6F7200
 1717              	.LC10:
 1718 009d 2E637376 		.ascii	".csv\000"
 1718      00
 1719              	.LC11:
 1720 00a2 4E4D4541 		.ascii	"NMEA\000"
 1720      00
 1721              	.LC12:
 1722 00a7 25730A00 		.ascii	"%s\012\000"
 1723              	.LC13:
 1724 00ab 00       		.ascii	"\000"
 1725              	.LC14:
 1726 00ac 2530366C 		.ascii	"%06ld,%5.2f,%5.2f,%5.2f,%5.2f,%5.2f,%5.2f,%5.2f,%5."
 1726      642C2535 
 1726      2E32662C 
 1726      25352E32 
 1726      662C2535 
 1727 00df 32662C25 		.ascii	"2f,%5.2f\012\015\000"
 1727      352E3266 
 1727      0A0D00
 1728              	.LC15:
 1729 00ea 2530366C 		.ascii	"%06ld,%5.2f,%5.2f,%5.2f\012\015\000"
 1729      642C2535 
 1729      2E32662C 
 1729      25352E32 
 1729      662C2535 
 1730              	.LC16:
 1731 0104 257300   		.ascii	"%s\000"
 1732              		.data
 1735              	minor_version:
 1736 0000 01       		.byte	1
 1737              		.bss
 1738              		.align	2
 1739              		.set	.LANCHOR0,. + 0
 1742              	configData:
 1743 0000 00000000 		.space	36
 1743      00000000 
 1743      00000000 
 1743      00000000 
 1743      00000000 
 1746              	sensorData:
 1747 0024 00000000 		.space	36
 1747      00000000 
 1747      00000000 
 1747      00000000 
 1747      00000000 
 1750              	gpsData:
 1751 0048 00000000 		.space	36
 1751      00000000 
 1751      00000000 
 1751      00000000 
 1751      00000000 
 1754              	sensors_updated:
 1755 006c 00       		.space	1
 1758              	sensor_log_string:
 1759 006d 00000000 		.space	255
 1759      00000000 
 1759      00000000 
 1759      00000000 
 1759      00000000 
 1762              	sensor_string:
 1763 016c 00000000 		.space	70
 1763      00000000 
 1763      00000000 
 1763      00000000 
 1763      00000000 
 1766              	major_version:
 1767 01b2 00       		.space	1
 1768 01b3 00       		.text
 1769              	.Letext0:
 1770              		.file 2 "../Library/sdfat/memory.h"
 1771              		.file 3 "configuration.h"
 1772              		.file 4 "../Library/i2c/I2C.h"
 1773              		.file 5 "../Library/adxl345/ADXL345.h"
 1774              		.file 6 "../Library/hmc5843/HMC5843.h"
 1775              		.file 7 "../Library/itg3200/ITG3200.h"
 1776              		.file 8 "../Library/sensor/sensor.h"
 1777              		.file 9 "../Library/em408/EM408.h"
 1778              		.file 10 "/opt/local/lib/gcc/arm-elf/4.6.1/../../../../arm-elf/include/stdint.h"
 1779              		.file 11 "../Library/timer/timer0ISR.h"
 1780              		.file 12 "../Library/uart/uart0ISR.h"
 1781              		.file 13 "../Library/uart/uart1ISR.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 main.cpp
/var/folders/vb/2fcwf0x52qn_fy1j7_hx1lpr0000gn/T//ccUIy0yY.s:5      .text:0000000000000000 $a
/var/folders/vb/2fcwf0x52qn_fy1j7_hx1lpr0000gn/T//ccUIy0yY.s:8      .text:0000000000000000 _Z6bootUpv
/var/folders/vb/2fcwf0x52qn_fy1j7_hx1lpr0000gn/T//ccUIy0yY.s:63     .text:0000000000000074 $d
/var/folders/vb/2fcwf0x52qn_fy1j7_hx1lpr0000gn/T//ccUIy0yY.s:71     .text:0000000000000088 $a
/var/folders/vb/2fcwf0x52qn_fy1j7_hx1lpr0000gn/T//ccUIy0yY.s:74     .text:0000000000000088 _Z5resetv
/var/folders/vb/2fcwf0x52qn_fy1j7_hx1lpr0000gn/T//ccUIy0yY.s:107    .text:00000000000000b8 _Z15initPeripheralsv
/var/folders/vb/2fcwf0x52qn_fy1j7_hx1lpr0000gn/T//ccUIy0yY.s:199    .text:0000000000000178 $d
/var/folders/vb/2fcwf0x52qn_fy1j7_hx1lpr0000gn/T//ccUIy0yY.s:207    .text:000000000000018c $a
/var/folders/vb/2fcwf0x52qn_fy1j7_hx1lpr0000gn/T//ccUIy0yY.s:210    .text:000000000000018c _Z7runTestv
/var/folders/vb/2fcwf0x52qn_fy1j7_hx1lpr0000gn/T//ccUIy0yY.s:403    .text:00000000000002ec $d
/var/folders/vb/2fcwf0x52qn_fy1j7_hx1lpr0000gn/T//ccUIy0yY.s:431    .text.startup:0000000000000000 $a
/var/folders/vb/2fcwf0x52qn_fy1j7_hx1lpr0000gn/T//ccUIy0yY.s:434    .text.startup:0000000000000000 main
/var/folders/vb/2fcwf0x52qn_fy1j7_hx1lpr0000gn/T//ccUIy0yY.s:1597   .text.startup:0000000000000dc8 $d
/var/folders/vb/2fcwf0x52qn_fy1j7_hx1lpr0000gn/T//ccUIy0yY.s:1646   .text.startup:0000000000000e78 $a
/var/folders/vb/2fcwf0x52qn_fy1j7_hx1lpr0000gn/T//ccUIy0yY.s:1648   .text.startup:0000000000000e78 _GLOBAL__sub_I_major_version
/var/folders/vb/2fcwf0x52qn_fy1j7_hx1lpr0000gn/T//ccUIy0yY.s:1681   .text.startup:0000000000000ea0 $d
/var/folders/vb/2fcwf0x52qn_fy1j7_hx1lpr0000gn/T//ccUIy0yY.s:1686   .ctors:0000000000000000 $d
/var/folders/vb/2fcwf0x52qn_fy1j7_hx1lpr0000gn/T//ccUIy0yY.s:1742   .bss:0000000000000000 configData
/var/folders/vb/2fcwf0x52qn_fy1j7_hx1lpr0000gn/T//ccUIy0yY.s:1750   .bss:0000000000000048 gpsData
/var/folders/vb/2fcwf0x52qn_fy1j7_hx1lpr0000gn/T//ccUIy0yY.s:1746   .bss:0000000000000024 sensorData
/var/folders/vb/2fcwf0x52qn_fy1j7_hx1lpr0000gn/T//ccUIy0yY.s:1758   .bss:000000000000006d sensor_log_string
/var/folders/vb/2fcwf0x52qn_fy1j7_hx1lpr0000gn/T//ccUIy0yY.s:1762   .bss:000000000000016c sensor_string
/var/folders/vb/2fcwf0x52qn_fy1j7_hx1lpr0000gn/T//ccUIy0yY.s:1754   .bss:000000000000006c sensors_updated
/var/folders/vb/2fcwf0x52qn_fy1j7_hx1lpr0000gn/T//ccUIy0yY.s:1735   .data:0000000000000000 minor_version
/var/folders/vb/2fcwf0x52qn_fy1j7_hx1lpr0000gn/T//ccUIy0yY.s:1766   .bss:00000000000001b2 major_version
/var/folders/vb/2fcwf0x52qn_fy1j7_hx1lpr0000gn/T//ccUIy0yY.s:1738   .bss:0000000000000000 $d
                     .debug_frame:0000000000000010 $d

UNDEFINED SYMBOLS
rprintf_devopen
init_serial0
putc_serial0
ISR_Timer0
ISR_UART1
ISR_UART0
_ZN8cADXL3455beginEc
_ZN8cITG32005beginEv
_ZN8cHMC58435beginEc
_ZN8cADXL34520setCalibrationValuesEiif
_ZN8cITG320020setCalibrationValuesEiii
_ZN6cEM4085beginEj
delay_ms
_ZN6cEM4082onEv
_ZN6cEM4087disableEv
_ZN6cEM4086enableEhh
configuration
accelerometer
gyro
compass
gps
rprintf
_ZN8cADXL3454readEPcc
_ZN8cITG32004readEPcc
_ZN8cHMC58434readEPcc
_Z12memoryDeletePc
__extendsfdf2
__floatunsidf
__truncdfsf2
__ltdf2
__divdf3
__muldf3
__adddf3
__gedf2
__floatsidf
__subdf3
__gtdf2
__eqdf2
_Z11memoryBeginv
timer0Init
timer0Match
_Z12memoryExistsPc
_Z14readConfigFile7cMemory
_Z16createConfigFile7cMemory
_ZN7cMemory6createEPKcS1_
uart1RxInt
uart0RxInt
_ZN8cADXL3456updateEv
_ZN8cITG32006updateEv
_ZN8cHMC58436updateEv
strcpy
_ZN7cMemory4saveEPc
_ZN7cMemory5closeEv
_Z10configMenu7cMemory
millis
_ZN8cITG32004getXEv
_ZN8cITG32004getYEv
_ZN8cITG32004getZEv
_ZN8cADXL3454getXEv
_ZN8cADXL3454getYEv
_ZN8cADXL3454getZEv
_ZN8cHMC58434getXEv
_ZN8cHMC58434getYEv
_ZN8cHMC58434getZEv
sprintf
_ZN7cSensor9fillRwAccEfff
_ZN7cSensor15normalizeVectorEPd
atan2
sin
cos
tan
sqrt
strcat
strlen
main_msc
filter
timer0IntFlag
uart1MessageComplete
uart1Message
uart0MessageComplete
_ZN7cMemoryC1Ev
